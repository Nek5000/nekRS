//
// nekRS User Defined File
//
#include <math.h>
#include "udf.hpp"
#include "plugins/lowMach.hpp"
#include "casedata.h"

static occa::kernel userVpKernel;
static occa::kernel userMeshVelocityKernel;

void qtl(nrs_t* nrs, dfloat time, occa::memory o_div)
{
  lowMach::qThermalPerfectGasSingleComponent(nrs, time, P_GAMMA, o_div);
}

void uservp(nrs_t *nrs, dfloat time, occa::memory o_U, occa::memory o_S,
            occa::memory o_UProp, occa::memory o_SProp)
{
  mesh_t *mesh = nrs->mesh;

  userVpKernel(mesh->Nelements, nrs->fieldOffset, nrs->cds->fieldOffset, nrs->p0th[0],
               o_S, o_UProp, o_SProp);
}

/* UDF Functions */                                                      

void UDF_LoadKernels(nrs_t *nrs)
{
  occa::properties& kernelInfo = *nrs->kernelInfo;
  kernelInfo["defines/p_PI"] = 4.0 * atan(1.0);
  userVpKernel = udfBuildKernel(nrs, "userVp");
  userMeshVelocityKernel = udfBuildKernel(nrs, "userMeshVelocity");
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  options.setArgs("MOVING MESH", "TRUE");
}

void UDF_Setup(nrs_t *nrs)
{
  udf.properties = &uservp;

  //lowMach::setup(nrs);
  //udf.div = &qtl;
}

dfloat min_vector(dfloat* y, int size)
{
  dfloat min = 9e30;
  for(int i = 0 ; i < size; ++i){
    min = (y[i] < min) ? y[i] : min;
  }
  return min;
}
dfloat max_vector(dfloat* y, int size)
{
  dfloat max = -9e30;
  for(int i = 0 ; i < size; ++i){
    max = (y[i] > max) ? y[i] : max;
  }
  return max;
}
void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
  mesh_t* mesh = nrs->mesh;
  linAlg_t* linAlg = linAlg_t::getInstance();
  // do host reduction
  mesh->o_y.copyTo(mesh->y, nrs->Nlocal * sizeof(dfloat));
  const dfloat ymin = linAlg->min(nrs->Nlocal, mesh->o_y, mesh->comm);
  const dfloat ymax = linAlg->max(nrs->Nlocal, mesh->o_y, mesh->comm);
  std::cout << "ymin = " << ymin << ", ymax = " << ymax << "\n";
  const dfloat host_ymin = min_vector(mesh->y, nrs->Nlocal);
  const dfloat host_ymax = max_vector(mesh->y, nrs->Nlocal);
  std::cout << "host_ymin = " << host_ymin << ", host_ymax = " << host_ymax << "\n";
#if 1
  userMeshVelocityKernel(mesh->Nelements,
    nrs->fieldOffset,
    ymin,
    ymax,
    time,
    mesh->o_y,
    mesh->o_U);
#endif

  //if (nrs->isOutputStep) {
    nek_ocopyFrom(time, tstep);
    nek_userchk();
  //}
}
