#if p_knl == 0
@kernel void ellipticPartialAxCoeffHex3D_v0(const dlong Nelements,
                                         const dlong offset,
                                         const dlong loffset,
                                         @ restrict const dlong *elementList,
                                         @ restrict const dfloat *ggeo,
                                         @ restrict const dfloat *D,
                                         @ restrict const dfloat *S,
                                         @ restrict const dfloat *lambda,
                                         @ restrict const dfloat *q,
                                         @ restrict dfloat *Aq)
{
  for (dlong e = 0; e < Nelements; ++e; @outer(0)) {
#if (p_Nq % 2 == 0)
    @shared dfloat s_D[p_Nq][p_Nq + 1];
#else
    @shared dfloat s_D[p_Nq][p_Nq];
#endif
    @shared dfloat s_q[p_Nq][p_Nq];

    @shared dfloat s_Gqr[p_Nq][p_Nq];
    @shared dfloat s_Gqs[p_Nq][p_Nq];

    @exclusive dfloat r_qt, r_Gqt, r_Auk;
    @exclusive dfloat r_q[p_Nq];
    @exclusive dfloat r_Aq[p_Nq];

    @exclusive dlong element;

    @exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
    @exclusive dfloat r_lam0, r_lam1;

    for (int j = 0; j < p_Nq; ++j; @inner(1))
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
        s_D[j][i] = D[p_Nq * j + i];
        element = elementList[e];
      }

    @barrier();

    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          const dlong base = i + j * p_Nq + element * p_Np;
          r_q[k] = q[base + k * p_Nq * p_Nq];
          r_Aq[k] = 0;
        }
      }
    }

    @barrier();

#pragma unroll p_Nq
    for (int k = 0; k < p_Nq; k++) {
      @barrier();
      for (int j = 0; j < p_Nq; ++j; @inner(1))
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

          r_G00 = ggeo[gbase + p_G00ID * p_Np];
          r_G01 = ggeo[gbase + p_G01ID * p_Np];
          r_G02 = ggeo[gbase + p_G02ID * p_Np];

          r_G11 = ggeo[gbase + p_G11ID * p_Np];
          r_G12 = ggeo[gbase + p_G12ID * p_Np];
          r_G22 = ggeo[gbase + p_G22ID * p_Np];

          r_GwJ = ggeo[gbase + p_GWJID * p_Np];

          const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          r_lam0 = lambda[id + 0 * offset];

#ifdef p_poisson
          r_lam1 = 0;
#else
          r_lam1 = lambda[id + 1 * offset];
#endif
        }

      @barrier();

      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          s_q[j][i] = r_q[k];

          r_qt = 0;

#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++)
            r_qt += s_D[k][m] * r_q[m];
        }
      }

      @barrier();

      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          dfloat qr = 0;
          dfloat qs = 0;

#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++) {
            qr += s_D[i][m] * s_q[j][m];
            qs += s_D[j][m] * s_q[m][i];
          }

          s_Gqs[j][i] = r_lam0 * (r_G01 * qr + r_G11 * qs + r_G12 * r_qt);
          s_Gqr[j][i] = r_lam0 * (r_G00 * qr + r_G01 * qs + r_G02 * r_qt);

          r_Gqt = r_lam0 * (r_G02 * qr + r_G12 * qs + r_G22 * r_qt);
          r_Auk = r_lam1 * r_GwJ * r_q[k];
        }
      }

      @barrier();

      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++) {
            r_Auk += s_D[m][j] * s_Gqs[m][i];
            r_Aq[m] += s_D[k][m] * r_Gqt;
            r_Auk += s_D[m][i] * s_Gqr[j][m];
          }

          r_Aq[k] += r_Auk;
        }
      }
    }

    @barrier();

    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          Aq[id] = r_Aq[k];
        }
      }
    }
  }
}
#endif

#if p_knl == 1

@kernel void ellipticPartialAxCoeffHex3D_v1(const dlong Nelements,
                                         const dlong offset,
                                         const dlong loffset,
                                         @ restrict const dlong *elementList,
                                         @ restrict const dfloat *ggeo,
                                         @ restrict const dfloat *D,
                                         @ restrict const dfloat *S,
                                         @ restrict const dfloat *lambda,
                                         @ restrict const dfloat *q,
                                         @ restrict dfloat *Aq)
{
  for (dlong e = 0; e < Nelements; ++e; @outer(0)) {
#if (p_Nq % 2 == 0)
    @shared dfloat s_D[p_Nq][p_Nq + 1];
#else
    @shared dfloat s_D[p_Nq][p_Nq];
#endif

    @exclusive dfloat r_Aq[p_Nq];

    @exclusive dlong element;

    @exclusive dfloat r_ur[p_Nq], r_us[p_Nq], r_ut[p_Nq];
    @shared dfloat s_tmp[p_Nq][p_Nq][p_Nq];    
    
    for (int j = 0; j < p_Nq; ++j; @inner(1))
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
        s_D[j][i] = D[p_Nq * j + i];
        element = elementList[e];
      }

    @barrier();

    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          const dlong base = i + j * p_Nq + element * p_Np;
          s_tmp[k][j][i] = q[base + k * p_Nq * p_Nq];
          r_Aq[k] = 0;
          r_ur[k] = 0;
          r_us[k] = 0;
          r_ut[k] = 0;
        }
      }
    }

    @barrier();

    // grad in r
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {          
        for (int m = 0; m < p_Nq; m++) {
          dfloat Dim = s_D[i][m];
#pragma unroll p_Nq          
          for (int k = 0; k < p_Nq; k++) {
            r_ur[k] += Dim * s_tmp[k][j][m];
          }
        }
      }
    }

    // grad in s
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {          
        for (int m = 0; m < p_Nq; m++) {
          dfloat Djm = s_D[j][m];
#pragma unroll p_Nq          
          for (int k = 0; k < p_Nq; k++) {
            r_us[k] += Djm * s_tmp[k][m][i];
          }
        }
      }
    }    
    
    // grad in t
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for (int m = 0; m < p_Nq; m++) {
          dfloat qm = s_tmp[m][j][i];
#pragma unroll p_Nq        
          for (int k = 0; k < p_Nq; k++) {          
            r_ut[k] += s_D[k][m] * qm;
          }
        }
      }
    }

    for (int k = 0; k < p_Nq; k++) {
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          
          dfloat r_G00 = ggeo[gbase + p_G00ID * p_Np];
          dfloat r_G01 = ggeo[gbase + p_G01ID * p_Np];
          dfloat r_G02 = ggeo[gbase + p_G02ID * p_Np];

          dfloat r_G11 = ggeo[gbase + p_G11ID * p_Np];
          dfloat r_G12 = ggeo[gbase + p_G12ID * p_Np];
          dfloat r_G22 = ggeo[gbase + p_G22ID * p_Np];

          dfloat r_GwJ = ggeo[gbase + p_GWJID * p_Np];

          const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          dfloat r_lam0 = lambda[id + 0 * offset];

#ifdef p_poisson
          dfloat r_lam1 = 0;
#else
          dfloat r_lam1 = lambda[id + 1 * offset];
#endif          

          dfloat t_Gqr = r_lam0 * (r_G00 * r_ur[k] + r_G01 * r_us[k] + r_G02 * r_ut[k]);          
          dfloat t_Gqs = r_lam0 * (r_G01 * r_ur[k] + r_G11 * r_us[k] + r_G12 * r_ut[k]);
          dfloat t_Gqt = r_lam0 * (r_G02 * r_ur[k] + r_G12 * r_us[k] + r_G22 * r_ut[k]);
          r_ur[k] = t_Gqr;
          r_us[k] = t_Gqs;
          r_ut[k] = t_Gqt;
          r_Aq[k] = r_lam1 * r_GwJ * s_tmp[k][j][i];
        }
      }
    }

    // div in t
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
        for (int k = 0; k < p_Nq; k++) {
          dfloat ut_kij = r_ut[k];
#pragma unroll p_Nq          
          for (int m = 0; m < p_Nq; m++) {
            r_Aq[m] += s_D[k][m] * ut_kij;
          }
        }
      }
    }
    // div in r
    @barrier("local");
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq        
        for (int k = 0; k < p_Nq; k++) {
          s_tmp[k][j][i] = r_ur[k];
        }
      }
    }
    @barrier("local");
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {    
        for (int m = 0; m < p_Nq; m++) {
          dfloat Dmi = s_D[m][i];
#pragma unroll p_Nq          
          for (int k = 0; k < p_Nq; k++) {
            r_Aq[k] += Dmi * s_tmp[k][j][m];
          }
        }
      }
    }
    // div in s
    @barrier("local");    
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq        
        for (int k = 0; k < p_Nq; k++) {
          s_tmp[k][j][i] = r_us[k];
        }
      }
    }
    @barrier("local");
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
        for (int m = 0; m < p_Nq; m++) {
          dfloat Dmj = s_D[m][j];
#pragma unroll p_Nq          
          for (int k = 0; k < p_Nq; k++) {
            r_Aq[k] += Dmj * s_tmp[k][m][i];
          }
        }
      }
    } 

    
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          Aq[id] = r_Aq[k];
        }
      }
    }
  }
}
#endif
