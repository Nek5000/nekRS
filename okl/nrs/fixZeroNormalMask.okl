void crossProduct(const dfloat a0, const dfloat a1, const dfloat a2,
  const dfloat b0, const dfloat b1, const dfloat b2,
  dfloat& c0, dfloat& c1, dfloat& c2)
{
  c0 = a1 * b2 - a2 * b1;
  c1 = a2 * b0 - a0 * b2;
  c2 = a0 * b1 - a1 * b0;

  const dfloat mag = sqrt(c0 * c0 + c1 * c1 + c2 * c2);
  const dfloat invMag = 1.0 / mag;
  c0 *= invMag;
  c1 *= invMag;
  c2 *= invMag;
}

dfloat dot(const dfloat a0, const dfloat a1, const dfloat a2, const dfloat b0, const dfloat b1, const dfloat b2)
{
  return a0 * b0 + a1 * b1 + a2 * b2;
}

@kernel void fixZeroNormalMask(const dlong Nelements,
                                         const dlong offset,
                                         @restrict dfloat*  sgeo,
                                         @restrict const dlong*  vmapM,
                                         @restrict const int*  EToB,
                                         @restrict const dfloat*  normal,
                                         @restrict dfloat* mask)
{
  for(dlong e = 0; e < Nelements; e++; @outer(0)) {

    for(int f = 0; f < p_Nfaces; f++) {
      for(int m = 0; m < p_Nfp; ++m; @inner(0)) {
        const int n = m + f * p_Nfp;
        const int sk = e * p_Nfp * p_Nfaces + n;
        const dlong sid  = e * p_Nfaces * p_Nfp + n;
        const dlong idM = vmapM[sk];
        const dlong bcType = EToB[f + p_Nfaces * e];

        if(bcType == p_ZERO_NORMAL) {

          const dfloat nx = sgeo[sid * p_Nsgeo + p_NXID];
          const dfloat ny = sgeo[sid * p_Nsgeo + p_NYID];
          const dfloat nz = sgeo[sid * p_Nsgeo + p_NZID];
          dfloat volNx = normal[idM + 0 * offset];
          dfloat volNy = normal[idM + 1 * offset];
          dfloat volNz = normal[idM + 2 * offset];
          dfloat count = normal[idM + 3 * offset];

          const dfloat invCount = 1.0 / count;
          volNx *= invCount;
          volNy *= invCount;
          volNz *= invCount;

          const dfloat volNMag = sqrt(volNx * volNx + volNy * volNy + volNz * volNz);

          const dfloat tol = 1e-6;
          if(abs(1.0-volNMag) > tol) {

            const dfloat invVolNMag = 1.0 / volNMag;
            volNx *= invVolNMag;
            volNy *= invVolNMag;
            volNz *= invVolNMag;

            const dfloat t1x = sgeo[sid * p_Nsgeo + p_T1XID];
            const dfloat t1y = sgeo[sid * p_Nsgeo + p_T1YID];
            const dfloat t1z = sgeo[sid * p_Nsgeo + p_T1ZID];

            const dfloat t2x = sgeo[sid * p_Nsgeo + p_T2XID];
            const dfloat t2y = sgeo[sid * p_Nsgeo + p_T2YID];
            const dfloat t2z = sgeo[sid * p_Nsgeo + p_T2ZID];

            dfloat NCrossT1x, NCrossT1y, NCrossT1z;
            crossProduct(nx, ny, nz, t1x, t1y, t1z, NCrossT1x, NCrossT1y, NCrossT1z);

            dfloat volNCrossT1x, volNCrossT1y, volNCrossT1z;
            crossProduct(volNx, volNy, volNz, t1x, t1y, t1z, volNCrossT1x, volNCrossT1y, volNCrossT1z);

            dfloat T2CrossNx, T2CrossNy, T2CrossNz;
            crossProduct(t2x, t2y, t2z, nx, ny, nz, T2CrossNx, T2CrossNy, T2CrossNz);

            dfloat T2CrossVolNx, T2CrossVolNy, T2CrossVolNz;
            crossProduct(t2x, t2y, t2z, volNx, volNy, volNz, T2CrossVolNx, T2CrossVolNy, T2CrossVolNz);

            const dfloat dot1 = dot(NCrossT1x, NCrossT1y, NCrossT1z, volNCrossT1x, volNCrossT1y, volNCrossT1z);
            const dfloat dot2 = dot(T2CrossNx, T2CrossNy, T2CrossNz, T2CrossVolNx, T2CrossVolNy, T2CrossVolNz);

            const dfloat tolN = 1e-7;

            if(dot1 < tolN || (1.0 - dot1) < tolN) {
              mask[idM + 0 * offset] = 0.0;
              mask[idM + 1 * offset] = 0.0;
              mask[idM + 2 * offset] = 1.0;

            } else if(dot2 < tolN || (1.0 - dot2) < tolN) {
              mask[idM + 0 * offset] = 0.0;
              mask[idM + 1 * offset] = 0.0;
              mask[idM + 2 * offset] = 1.0;

              sgeo[sid * p_Nsgeo + p_T1XID] = t2x;
              sgeo[sid * p_Nsgeo + p_T1YID] = t2y;
              sgeo[sid * p_Nsgeo + p_T1ZID] = t2z;

              sgeo[sid * p_Nsgeo + p_T2XID] = t1x;
              sgeo[sid * p_Nsgeo + p_T2YID] = t1y;
              sgeo[sid * p_Nsgeo + p_T2ZID] = t1z;

            } else {
              // corner
              mask[idM + 0 * offset] = 0.0;
              mask[idM + 1 * offset] = 0.0;
              mask[idM + 2 * offset] = 0.0;
            }
          }

        }
      }
      @barrier("global");
    }
  }

}
