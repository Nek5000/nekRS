//
// nekRS User Defined File
//
#include <limits.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include "udf.hpp"
#include "particle.hpp"

#include "casedata.h"

#define PART_K 50
#define PART_M 50
#define PART_N 50
#define D 3

#define USE_HOST_FINDPTS       false
#define USE_HOST_FINDPTS_EVAL  false
#define USE_MIGRATE            false
#define USE_LOCAL_FINDPTS_EVAL false
#define CHECK_ACCURACY         false
static_assert(USE_MIGRATE || !USE_LOCAL_FINDPTS_EVAL, "Cannot use local eval w/out migration");

#define OUT_CHUNK_SIZE 10000 /* chunk size for outputing particles */

struct gabls_particle_data {
  dfloat v_hist[2][D];
  hlong  id;
  dfloat color;

  gabls_particle_data()
  {
  }

  gabls_particle_data(dfloat v_hist_[2][D], dfloat color_, hlong id_)
  {
    for (int i = 0; i < 2; ++i) {
      for (int j = 0; j < D; ++j) {
        v_hist[i][j] = v_hist_[i][j];
      }
    }
    id = id_;
    color = color_;
  }
};

/* Particle Functions */
void particle_init(particle_set<D,gabls_particle_data>& particles) {

  static hlong gcount = 0;

  int mpi_rank = platform_t::getInstance()->comm.mpiRank;
  int mpi_size = platform_t::getInstance()->comm.mpiCommSize;

  hlong k  = gcount; // total # particles emitted

  // spawn PART_COUNT particles in (0.0, 4.0)x(0.0, 4.0)x(0.0, 4.0)
  for (int ix = 0; ix < PART_K; ++ix) {
    for (int iy = 0; iy < PART_M; ++iy) {
      for (int iz = 0; iz < PART_N; ++iz) {

        dfloat dx = 4.0/(PART_K+1), dy = 4.0/(PART_M+1), dz = 4.0/(PART_N+1);
        dfloat xp = dx*(ix+1),      yp = dy*(iy+1),      zp = dz*(iz+1);

        if (k%mpi_size == mpi_rank) { // Inject particle _only_ on this processor
          particle_set<D,gabls_particle_data>::particle_t particle;

          particle.x[0] = xp;
          particle.x[1] = yp;
          particle.x[2] = zp;
          particle.extra.id = k;
          for (int d = 0; d < D; ++d) {
            particle.extra.v_hist[0][d] = 0.0;
            particle.extra.v_hist[1][d] = 0.0;
          }
//        particle.extra.color = time;    // color by spawning timestep
          particle.extra.color = k;       // color by id

          particles.push(particle);
        }
        ++k; // Total count
      }
    }
  }

  gcount = k;
}


void particle_advect_std(particle_set<D,gabls_particle_data>& particles, int tstep) {


  ////////// particles.find() //////////
  if(CHECK_ACCURACY){
    int mpi_rank = platform_t::getInstance()->comm.mpiRank;
    particle_set<D,gabls_particle_data> particles_copy = particles;
    dfloat *dist2_dev = new dfloat[particles.size()];
    dfloat *dist2_ref = new dfloat[particles.size()];
    particles.find(true, dist2_dev);
    particles_copy.find(false, dist2_ref);

    auto&    x     = particles     .x;
    auto& code_dev = particles     .code;
    auto& proc_dev = particles     .proc;
    auto&   el_dev = particles     .el;
    auto&    r_dev = particles     .r;
    auto& code_ref = particles_copy.code;
    auto& proc_ref = particles_copy.proc;
    auto&   el_ref = particles_copy.el;
    auto&    r_ref = particles_copy.r;

    for (int i = 0; i < particles.size(); ++i) {
      if (code_ref[i] != code_dev[i]
          || (code_ref[i] != 2
              && (   proc_ref[i] != proc_dev[i]
                  ||   el_ref[i] !=   el_dev[i]
                  || (dist2_dev[i]>1e-17 && dist2_ref[i]*2 < dist2_dev[i])))) {
        printf("%d: WARNING: ogs_findpts varied at %4d: %e, %e, %e\n",
               mpi_rank, i, x[0][i], x[1][i], x[2][i]);
        printf("%d:                          %1d, %3d, %4d, %e, %e, %e, %e\n",
               mpi_rank, code_ref[i], proc_ref[i], el_ref[i], r_ref[i][0], r_ref[i][1], r_ref[i][2], dist2_ref[i]);
        printf("%d:                          %1d, %3d, %4d, %e, %e, %e, %e\n",
               mpi_rank, code_dev[i], proc_dev[i], el_dev[i], r_dev[i][0], r_dev[i][1], r_dev[i][0], dist2_dev[i]);
      }
    }
    delete [] dist2_dev;
    delete [] dist2_ref;
    if(USE_HOST_FINDPTS){
      particles=particles_copy;
    }
  }else{
    particles.find(!USE_HOST_FINDPTS);
  }

  ////////// particles.migrate() //////////
  if(USE_MIGRATE) {
    particles.migrate();
  }

  ////////// particles.interp() //////////
  dlong eval_counts = CHECK_ACCURACY ? 2 : 1;
  dfloat *u_alloc = new dfloat[D*particles.size()*eval_counts], *u_base[D*2];
  for (int i = 0; i < D*eval_counts; ++i) {
    u_base[i]   = u_alloc;
    u_alloc += particles.size();
  }
  dfloat **u_host, **u_occa, **u_base_next = u_base;
  if (!USE_HOST_FINDPTS_EVAL || CHECK_ACCURACY) {
    u_occa = u_base_next; u_base_next += D;
    occa::memory o_U = particles.nrs->o_U.cast(occa::dtype::get<dfloat>());
    if(USE_LOCAL_FINDPTS_EVAL){
      particles.interp_local(o_U, u_occa, D);
    }else{
      particles.interp(o_U, u_occa, D);
    }
  }
  if (USE_HOST_FINDPTS_EVAL || CHECK_ACCURACY) {
    u_host = u_base_next;
    if(USE_LOCAL_FINDPTS_EVAL){
      particles.interp_local(particles.nrs->U, u_host, D);
    }else{
      particles.interp(particles.nrs->U, u_host, D);
    }
  }
  if (CHECK_ACCURACY) {
    // controls the tolerences for printing warnings
    const dfloat abs_tol = 2e-15;
    const dfloat rel_tol = 1;

    for (int i = 0; i < particles.size(); ++i) {
      for (int j = 0; j < D; ++j) {
        dfloat out_occa = u_occa[j][i];
        dfloat out_host = u_host[j][i];
        if (std::abs(out_host - out_occa) > abs_tol
            || std::abs(out_host - out_occa) > rel_tol*std::abs(out_host)) {
          printf("WARNING: ogs_findpts_eval varied at point %d coord %d: %e != %e (diff %e)\n",
                 i, j, out_host, out_occa, out_host-out_occa);
        }
      }
    }
  }
  dfloat **u1 = USE_HOST_FINDPTS_EVAL ? u_host : u_occa;

  double c1, c2, c3, dt = particles.nrs->dt[0];
  if (tstep == 0) { // AB1
    c1 = 1.0;
    c2 = 0.0;
    c3 = 0.0;
  } else if (tstep == 1) { // AB2
    c1 =  3.0 / 2.0;
    c2 = -1.0 / 2.0;
    c3 =  0.0 / 2.0;
  } else { // AB3
    c1 =  23.0 / 12.0;
    c2 = -16.0 / 12.0;
    c3 =   5.0 / 12.0;
  }

  for (int i = 0; i < particles.size(); ++i) {
    // Update particle position and velocity history
    for (int k=0; k < D; ++k) {
       particles.x[k][i] += dt*(c1*u1[k][i] + c2*particles.extra[i].v_hist[0][k] + c3*particles.extra[i].v_hist[1][k]);
       particles.extra[i].v_hist[0][k] = particles.extra[i].v_hist[1][k];
       particles.extra[i].v_hist[1][k] = u1[k][i];
    }

    // x and z have periodic boundaries
    if (particles.x[0][i] > 4) particles.x[0][i] -= 4;
    if (particles.x[0][i] < 0) particles.x[0][i] += 4;
    if (particles.x[2][i] > 4) particles.x[2][i] -= 4;
    if (particles.x[2][i] < 0) particles.x[2][i] += 4;
  }

  delete[] u_base[0];
}

void particle_out(particle_set<D,gabls_particle_data>& particles)
{
  constexpr dlong entry_len = D+1;
  static dfloat x_temp[OUT_CHUNK_SIZE][entry_len];
  static dfloat x_root[OUT_CHUNK_SIZE][entry_len];

  static int out_step = 0;
  ++out_step;

  MPI_Comm mpi_comm = platform_t::getInstance()->comm.mpiComm;
  int mpi_rank = platform_t::getInstance()->comm.mpiRank;
  int mpi_size = platform_t::getInstance()->comm.mpiCommSize;
  dlong npart = particles.size();

  std::FILE *file_out;
  if (mpi_rank == 0) {
    char fname[128];
    sprintf(fname, "part%05d.3d", out_step);
    file_out = fopen(fname, "w+");
    fprintf(file_out, "X Y Z Color\n");
  }

  hlong l_min = INT_MAX, l_max = INT_MIN, min_points, max_points;
  for (int i = 0; i < npart; ++i) {
    hlong id = particles.extra[i].id;
    if (l_min > id) {
      l_min = id;
    }
    if (l_max < id) {
      l_max = id;
    }
  }
  MPI_Allreduce(&l_min, &min_points, 1, MPI_HLONG, MPI_MIN, mpi_comm);
  MPI_Allreduce(&l_max, &max_points, 1, MPI_HLONG, MPI_MAX, mpi_comm);

  hlong n_active = max_points - min_points + 1;
  dlong npass = n_active / OUT_CHUNK_SIZE;
  if (n_active > npass*OUT_CHUNK_SIZE) ++npass;
  hlong ilast=min_points;

  for (int ipass = 0; ipass < npass; ++ipass) {
    dlong mpart = (dlong)std::min((hlong)OUT_CHUNK_SIZE, max_points - ilast+1);
    hlong i0 = ilast;
    hlong i1 = i0 + mpart;
    ilast = i1;

    memset(&x_temp[0][0], 0, mpart*entry_len*sizeof(dfloat));
    for (int ii=0; ii < npart; ++ii) {
      hlong id = particles.extra[ii].id;
      if (i0 <= id && id < i1) {
        int i = id-i0;
        for (int j = 0; j < D; ++j) {
          x_temp[i][j] = particles.x[j][ii];       // coordinates
        }
        x_temp[i][D] = particles.extra[ii].color;  // color
      }
    }

    MPI_Reduce(&x_temp[0][0], &x_root[0][0], mpart*entry_len, MPI_DFLOAT, MPI_SUM, 0, mpi_comm);
    if (mpi_rank == 0) {
      for (int i = 0; i < mpart; ++i) {
        for (int j = 0; j < D+1; ++j) {
          fprintf(file_out, " %17.9e", x_root[i][j]);
        }
        fprintf(file_out, "\n");
      }
    }
  }

  if (mpi_rank == 0) fclose(file_out);
}

particle_set<D,gabls_particle_data> *particle_data;

void my_particle_generator(nrs_t *nrs, dfloat time, int tstep)
{
  bool ifnewpart;
  // adjust to control when particles are generated
//static dfloat last_new_time = 0.0;
//ifnewpart = time - last_new_time >= 0.5; // every 0.5 seconds
//if(ifnewpart) last_new_time = time;
//ifnewpart = tstep % 100;                 // every 100 iterations
//ifnewpart = nrs->isOutputStep;           // on the output steps
  ifnewpart = tstep == 0;                     // only generate particles on the first step

  // Only output particles on output steps to ensure particles match the field files
  bool ifoutpart = nrs->isOutputStep;

  if (ifnewpart) particle_init(*particle_data);
  particle_advect_std         (*particle_data, tstep);
  if (ifoutpart) particle_out (*particle_data);
}


/* User Functions */

occa::kernel coriolisKernel;

void userf(nrs_t *nrs, dfloat time, occa::memory o_U, occa::memory o_FU)
{
  mesh_t* mesh = nrs->meshV;
  coriolisKernel(
    mesh->Nlocal,
    nrs->fieldOffset,
    nrs->meshV->o_y,
    nrs->cds->o_S,
    nrs->o_U,
    o_FU);
}


/* UDF Functions */

void UDF_LoadKernels(nrs_t *nrs)
{
  particle_data = new particle_set<D,gabls_particle_data>(nrs, 0);

  occa::properties& kernelInfo = *nrs->kernelInfo;
  setupAide &options = platform->options;

  dfloat cond;
  options.getArgs("SCALAR00 DIFFUSIVITY", cond);
  const dfloat g = 9.81;
  const dfloat omega = 7.2921159e-5;

  kernelInfo["defines/p_fcor"]      = 2*omega*LREF/UREF * sin(NLAT*M_PI/180);
  kernelInfo["defines/p_bcor"]      = 2*omega*LREF/UREF * cos(NLAT*M_PI/180);
  kernelInfo["defines/p_gacc"]      = LREF*g/(UREF*UREF);
  kernelInfo["defines/p_cond"]      = cond;
  kernelInfo["defines/p_TsGrad"]    = ILSTRENGTH * LREF/TREF;
  kernelInfo["defines/p_T0s"]       = TS0/TREF;
  kernelInfo["defines/p_sCoolRate"] = SCR * LREF/TREF/UREF/3600;
  kernelInfo["defines/p_YLEN"]      = YLEN;

  coriolisKernel = udfBuildKernel(nrs, "coriolis");
}

void UDF_Setup(nrs_t *nrs)
{
  udf.uEqnSource = &userf;

  int mpi_rank = platform_t::getInstance()->comm.mpiRank;
  int mpi_size = platform_t::getInstance()->comm.mpiCommSize;
  if (mpi_rank == 0) {
    std::cout << "Particle config: " << PART_K << "x" << PART_M << "x" << PART_N << " particle grid "
                                     << "with " << (USE_HOST_FINDPTS ? "host" : "OCCA") << " findpts"
                                     << "and " << (USE_HOST_FINDPTS_EVAL ? "host" : "OCCA") << " findpts_eval" << std::endl;
  }
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
  if (USE_HOST_FINDPTS_EVAL || CHECK_ACCURACY) {
    nrs->o_U.copyTo(nrs->U);
  }
  my_particle_generator(nrs, time, tstep);
}
