// Boundary conditions

void exact(dfloat *uu, dfloat *vv, const dfloat xx, const dfloat yy,
           const dfloat time, const dfloat visc)
{
      dfloat a [2][5] = {
        {-0.2, 0.25, 0, 0, 0},
        {-0.2,  0.0, 0, 0, 0}
      };

      dfloat cpsi[2][5] = {
        {0.0, 3.0, 0, 0, 0},
        {5.0, 4.0, 0, 0, 0}
      };

      dfloat aa, arg, e;
      dfloat x, u, cx, sx;
      dfloat c1, c2;
      dfloat s1x, c1x, s2x, c2x;
      dfloat s1y, c1y, s2y, c2y;
      dfloat y, v, cy, sy;

      int i,k;

      aa    = cpsi[1][0]*cpsi[1][0];
      arg   = -visc*time*aa;
      e     = exp(arg);

      x = xx - p_u0*time;
      y = yy - p_v0*time;

      sx = sin(cpsi[1][0]*x);
      cx = cos(cpsi[1][0]*x);
      sy = sin(cpsi[1][0]*y);
      cy = cos(cpsi[1][0]*y);
      u  = a[0][0]*cpsi[1][0]*cy; 
      v  = a[1][0]*cpsi[1][0]*sx;

      for(k=1; k<5; ++k){
         s1x = sin(cpsi[0][k]*x);
         c1x = cos(cpsi[0][k]*x);
         s2x = sin(cpsi[1][k]*x);
         c2x = cos(cpsi[1][k]*x);

         s1y = sin(cpsi[0][k]*y);
         c1y = cos(cpsi[0][k]*y);
         s2y = sin(cpsi[1][k]*y);
         c2y = cos(cpsi[1][k]*y);
         
         c1  = cpsi[0][k];
         c2  = cpsi[1][k];

         if (k==1) u = u + a[0][k]*s1x*c2y*c2;
         if (k==1) v = v - a[0][k]*c1x*s2y*c1;
         if (k==1) u = u - a[1][k]*s2x*c1y*c1;
         if (k==1) v = v + a[1][k]*c2x*s1y*c2;

         if (k==2) u = u - a[0][k]*s1x*c2y*c2;
         if (k==2) v = v + a[0][k]*c1x*s2y*c1;
         if (k==2) u = u - a[1][k]*c2x*c1y*c1;
         if (k==2) v = v - a[1][k]*s2x*s1y*c2;

         if (k==3) u = u + a[0][k]*c1x*c2y*c2;
         if (k==3) v = v + a[0][k]*s1x*s2y*c1;
         if (k==3) u = u + a[1][k]*c2x*c1y*c1;
         if (k==3) v = v + a[1][k]*s2x*s1y*c2;

         if (k==4) u = u - a[0][k]*s1x*c2y*c2;
         if (k==4) v = v + a[0][k]*c1x*s2y*c1;
         if (k==4) u = u - a[1][k]*s2x*c1y*c1;
         if (k==4) v = v + a[1][k]*c2x*s1y*c2;
      }
      *uu = u*e + p_u0;
      *vv = v*e + p_v0;
}

void velocityDirichletConditions(bcData *bc)
{
  dfloat u, v;
  exact(&u, &v, bc->x, bc->y, bc->time, p_nu);
  bc->u = u;
  bc->v = v;
  bc->w = 0;
}

@kernel void exactVelocity(const dlong Ntotal,
                    const dlong offset,
                    const dfloat time,
                    @restrict const dfloat * x_coords,
                    @restrict const dfloat * y_coords,
                    @restrict dfloat * U)
{
  for(dlong n=0;n<Ntotal;++n;@tile(256,@outer,@inner)){
      dfloat u, v, x, y;
      x = x_coords[n];
      y = y_coords[n];
      exact(&u, &v, x, y, time, p_nu);
      U[n + 0 * offset] = u;
      U[n + 1 * offset] = v;
      U[n + 2 * offset] = 0.0;
  }
}

@kernel void userMeshVelocity(const dlong Ntotal,
                    const dlong offset,
                    const dfloat time,
                    @restrict const dfloat * x,
                    @restrict const dfloat * y,
                    @restrict dfloat * W)
{
  for(dlong n=0;n<Ntotal;++n;@tile(256,@outer,@inner)){
      const dfloat amp = p_amp*p_omega*cos(p_omega*time);
      const dfloat amp2 = p_amp*p_omega*cos(0.5*p_omega*time);
      const dfloat arx = x[n] / p_xlen;
      const dfloat ary = y[n] / p_ylen;
      W[n + 0 * offset] = amp2 * sin(p_pi*ary);
      W[n + 1 * offset] = amp*sin(p_pi*arx)*ary - amp*sin(p_pi*arx)*(1.-ary);
      W[n + 2 * offset] = 0.0;
  }
}
