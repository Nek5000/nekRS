//
// nekRS User Defined File
//
#include "udf.hpp"
#include "nekrsAscent.hpp"
#include "nekrsAscent.cpp"

#ifdef __okl__

#include "pb.oudf"

#endif

void UDF_Setup(nrs_t *nrs) {
/*
  cds_t *cds = nrs->cds;
  mesh_t *meshV = nrs->meshV; 
  mesh_t* meshT;
  (nrs->cds) ? meshT = cds->mesh[0] : meshT = meshV; // cht

  {
    std::vector< std::tuple<std::string, occa::memory, dlong> > ascentFields;

    auto o_u    = nrs->o_U.slice(0 * nrs->fieldOffset , nrs->fieldOffset);
    auto o_v    = nrs->o_U.slice(1 * nrs->fieldOffset , nrs->fieldOffset);
    auto o_w    = nrs->o_U.slice(2 * nrs->fieldOffset , nrs->fieldOffset);

    ascentFields.push_back(std::make_tuple("vel_x", o_u, meshV->Nlocal));
    ascentFields.push_back(std::make_tuple("vel_y", o_v, meshV->Nlocal));
    ascentFields.push_back(std::make_tuple("vel_z", o_w, meshV->Nlocal));

//    ascentFields.push_back(std::make_tuple("radius", o_rad));

    for (int is = 0; is < cds->NSfields; is++) {
      const std::string sid = (is==0) ? "temperature" : "scalar" + scalarDigitStr(is);

      mesh_t *mesh;
      (is) ? mesh = cds->meshV : mesh = cds->mesh[0];
      auto o_scalar = cds->o_S + cds->fieldOffsetScan[is];
      ascentFields.push_back(std::make_tuple(sid, o_scalar, mesh->Nlocal));
    }

    nekrsAscent::setup(meshT, nrs->fieldOffset, ascentFields); // TODO: add order for map2reg;, Nlocal
  }
*/
  nekrsAscent::setup(nrs);
}

void UDF_ExecuteStep(nrs_t *nrs, double time, int tstep) {

  cds_t *cds = nrs->cds;
  mesh_t* meshT; 
  (nrs->cds) ? meshT = cds->mesh[0] : meshT = nrs->meshV; 

  // compute radius, stored it in scalar01
  occa::memory o_S1 = cds->o_S + cds->fieldOffsetScan[1];
  if (tstep==0)
    compRad(meshT->Nlocal, meshT->o_x, meshT->o_y, o_S1);

  // insitu
  nekrsAscent::run(time, tstep);
}
