#include <casedata.h>
// Boundary conditions
void exact(dfloat *uu, dfloat *vv, const dfloat xx, const dfloat yy,
           const dfloat time, const dfloat visc)
{
      const dfloat u0 = 1.0; 
      const dfloat v0 = 0.3;

      dfloat a [2][5] = {
        {-0.2, 0.25, 0, 0, 0},
        {-0.2,  0.0, 0, 0, 0}
      };

      dfloat cpsi[2][5] = {
        {0.0, 3.0, 0, 0, 0},
        {5.0, 4.0, 0, 0, 0}
      };

      dfloat pi, aa, arg, e;
      dfloat x, u, cx, sx;
      dfloat c1, c2;
      dfloat s1x, c1x, s2x, c2x;
      dfloat s1y, c1y, s2y, c2y;
      dfloat y, v, cy, sy;

      int i,k;

      pi    = M_PI;

      aa    = cpsi[1][0]*cpsi[1][0];
      arg   = -visc*time*aa;
      e     = exp(arg);

      x = xx - u0*time;
      y = yy - v0*time;

      sx = sin(cpsi[1][0]*x);
      cx = cos(cpsi[1][0]*x);
      sy = sin(cpsi[1][0]*y);
      cy = cos(cpsi[1][0]*y);
      u  = a[0][0]*cpsi[1][0]*cy; 
      v  = a[1][0]*cpsi[1][0]*sx;

      for(k=1; k<5; ++k){
         s1x = sin(cpsi[0][k]*x);
         c1x = cos(cpsi[0][k]*x);
         s2x = sin(cpsi[1][k]*x);
         c2x = cos(cpsi[1][k]*x);

         s1y = sin(cpsi[0][k]*y);
         c1y = cos(cpsi[0][k]*y);
         s2y = sin(cpsi[1][k]*y);
         c2y = cos(cpsi[1][k]*y);
         
         c1  = cpsi[0][k];
         c2  = cpsi[1][k];

         if (k==1) u = u + a[0][k]*s1x*c2y*c2;
         if (k==1) v = v - a[0][k]*c1x*s2y*c1;
         if (k==1) u = u - a[1][k]*s2x*c1y*c1;
         if (k==1) v = v + a[1][k]*c2x*s1y*c2;

         if (k==2) u = u - a[0][k]*s1x*c2y*c2;
         if (k==2) v = v + a[0][k]*c1x*s2y*c1;
         if (k==2) u = u - a[1][k]*c2x*c1y*c1;
         if (k==2) v = v - a[1][k]*s2x*s1y*c2;

         if (k==3) u = u + a[0][k]*c1x*c2y*c2;
         if (k==3) v = v + a[0][k]*s1x*s2y*c1;
         if (k==3) u = u + a[1][k]*c2x*c1y*c1;
         if (k==3) v = v + a[1][k]*s2x*s1y*c2;

         if (k==4) u = u - a[0][k]*s1x*c2y*c2;
         if (k==4) v = v + a[0][k]*c1x*s2y*c1;
         if (k==4) u = u - a[1][k]*s2x*c1y*c1;
         if (k==4) v = v + a[1][k]*c2x*s1y*c2;
      }
      *uu = u*e + u0;
      *vv = v*e + v0;
}
void velocityDirichletConditions(bcData *bc)
{
  dfloat u, v;
  exact(&u, &v, bc->x, bc->y, bc->time, p_nu);
  bc->u = u;
  bc->v = v;
  bc->w = 0;
}
@kernel void exactVelocity(const dlong Nelements,
                    const dlong offset,
                    const dfloat time,
                    @restrict const dfloat * x_coords,
                    @restrict const dfloat * y_coords,
                    @restrict dfloat * U)
{
  for(dlong e=0;e<Nelements;++e;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int id = e*p_Np + n;
      dfloat u, v, x, y;
      x = x_coords[id];
      y = y_coords[id];
      exact(&u, &v, x, y, time, p_nu);
      U[id + 0 * offset] = u;
      U[id + 1 * offset] = v;
      U[id + 2 * offset] = 0.0;
    }
  }
}
@kernel void userMeshVelocity(const dlong Nelements,
                    const dlong offset,
                    const dfloat time,
                    @restrict const dfloat * x,
                    @restrict const dfloat * y,
                    @restrict dfloat * W)
{
  for(dlong e=0;e<Nelements;++e;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int id = e*p_Np + n;
      const dfloat amp = P_AMP*P_OMEGA*cos(P_OMEGA*time);
      const dfloat amp2 = P_AMP*P_OMEGA*cos(0.5*P_OMEGA*time);
      const dfloat arx = x[id] / XLEN;
      const dfloat ary = y[id] / XLEN;
      W[id + 0 * offset] = amp2 * sin(P_PI*ary);
      W[id + 1 * offset] = amp*sin(P_PI*arx)*ary - amp*sin(P_PI*arx)*(1.-ary);
      W[id + 2 * offset] = 0.0;
    }
  }
}
