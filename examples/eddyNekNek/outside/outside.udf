
//
// nekRS User Defined File
//
#include "udf.hpp"
#include "ci.inc"

static dfloat P_U0;
static dfloat P_V0;
static dfloat P_OMEGA;
static dfloat P_SCALE;

#ifdef __okl__
void exact(dfloat *uu, dfloat *vv, dfloat *ww, dfloat xx, dfloat yy, dfloat zz, double time, dfloat visc)
{
  const dfloat a[10] = {-.2, -.2, .25, 0.0, 0, 0, 0, 0, 0, 0};
  const dfloat cpsi[10] = {0, 5, 3, 4, 0, 0, 0, 0, 0, 0};

  const dfloat aa = cpsi[1] * cpsi[1];
  const dfloat arg = -visc * time * aa; // domain is [0:2pi]
  const dfloat e = exp(arg);

  const dfloat x = xx - p_U0 * time;
  const dfloat y = yy - p_V0 * time;
  const dfloat z = 0.0;

  const dfloat sx = sin(cpsi[1] * x);
  const dfloat cx = cos(cpsi[1] * x);
  const dfloat sy = sin(cpsi[1] * y);
  const dfloat cy = cos(cpsi[1] * y);
  dfloat u = a[0] * cpsi[1] * cy;
  dfloat v = a[1] * cpsi[1] * sx;

  for (int k = 2; k <= 5; ++k) {

    const dfloat s1x = sin(cpsi[0 + 2 * (k - 1)] * x);
    const dfloat c1x = cos(cpsi[0 + 2 * (k - 1)] * x);
    const dfloat s2x = sin(cpsi[1 + 2 * (k - 1)] * x);
    const dfloat c2x = cos(cpsi[1 + 2 * (k - 1)] * x);

    const dfloat s1y = sin(cpsi[0 + 2 * (k - 1)] * y);
    const dfloat c1y = cos(cpsi[0 + 2 * (k - 1)] * y);
    const dfloat s2y = sin(cpsi[1 + 2 * (k - 1)] * y);
    const dfloat c2y = cos(cpsi[1 + 2 * (k - 1)] * y);

    const dfloat c1 = cpsi[0 + 2 * (k - 1)];
    const dfloat c2 = cpsi[1 + 2 * (k - 1)];

    if (k == 2) {
      u = u + a[0 + 2 * (k - 1)] * s1x * c2y * c2;
      v = v - a[0 + 2 * (k - 1)] * c1x * s2y * c1;
      u = u - a[1 + 2 * (k - 1)] * s2x * c1y * c1;
      v = v + a[1 + 2 * (k - 1)] * c2x * s1y * c2;
    }

    if (k == 3) {
      u = u - a[0 + 2 * (k - 1)] * s1x * c2y * c2;
      v = v + a[0 + 2 * (k - 1)] * c1x * s2y * c1;
      u = u - a[1 + 2 * (k - 1)] * c2x * c1y * c1;
      v = v - a[1 + 2 * (k - 1)] * s2x * s1y * c2;
    }

    if (k == 4) {
      u = u + a[0 + 2 * (k - 1)] * c1x * c2y * c2;
      v = v + a[0 + 2 * (k - 1)] * s1x * s2y * c1;
      u = u + a[1 + 2 * (k - 1)] * c2x * c1y * c1;
      v = v + a[1 + 2 * (k - 1)] * s2x * s1y * c2;
    }

    if (k == 5) {
      u = u - a[0 + 2 * (k - 1)] * s1x * c2y * c2;
      v = v + a[0 + 2 * (k - 1)] * c1x * s2y * c1;
      u = u - a[1 + 2 * (k - 1)] * s2x * c1y * c1;
      v = v + a[1 + 2 * (k - 1)] * c2x * s1y * c2;
    }
  }
  (*uu) = u * e + p_U0;
  (*vv) = v * e + p_V0;
  (*ww) = 0.0;
}

// Boundary conditions
void velocityDirichletConditions(bcData *bc)
{
  bc->u = bc->uinterp;
  bc->v = bc->vinterp;
  bc->w = bc->winterp;
}

void scalarDirichletConditions(bcData *bc)
{
  bc->s = bc->sinterp;
}

@kernel void exactUVW(const dlong Ntotal,
                      const dlong offset,
                      const double time,
                      @ restrict const dfloat *X,
                      @ restrict const dfloat *Y,
                      @ restrict const dfloat *Z,
                      @ restrict dfloat *U)
{
  for (dlong n = 0; n < Ntotal; ++n; @tile(p_blockSize, @outer, @inner)) {
    dfloat u, v, w;
    const dfloat x = X[n];
    const dfloat y = Y[n];
    const dfloat z = Z[n];
    exact(&u, &v, &w, x, y, z, time, p_visc);
    U[n + 0 * offset] = u;
    U[n + 1 * offset] = v;
    U[n + 2 * offset] = w;
  }
}

void dP(dfloat *dpdx, dfloat xx, dfloat yy, dfloat zz, dfloat time, dfloat visc)
{
  const dfloat e = exp(-50 * time * visc);

  const dfloat x = xx - p_U0 * time;
  const dfloat y = yy - p_V0 * time;

  dfloat dp = e / 64.0;
  dp *= -96 * sin(6 * x) + 64 * sin(2 * x - 4 * y) - 64 * sin(2 * x + 4 * y) - 64 * sin(8 * x - 4 * y) +
        64 * sin(8 * x + 4 * y) - 12 * cos(3 * x - 9 * y) + 108 * cos(3 * x - y) + 108 * cos(3 * x + y) -
        12 * cos(3 * x + 9 * y) + 160 * cos(5 * x - 5 * y) - 160 * cos(5 * x + 5 * y);
  (*dpdx) = dp;
}

@kernel void dpdx(const dlong Ntotal,
                  const dfloat time,
                  @ restrict const dfloat *X,
                  @ restrict const dfloat *Y,
                  @ restrict const dfloat *Z,
                  @ restrict dfloat *FS)
{
  for (dlong n = 0; n < Ntotal; ++n; @tile(p_blockSize, @outer, @inner)) {
    dfloat dpdx;
    const dfloat x = X[n];
    const dfloat y = Y[n];
    const dfloat z = Z[n];
    dP(&dpdx, x, y, z, time, p_visc);
    FS[n] = -dpdx;
  }
}

@kernel void userMeshVelocity(const dlong Ntotal,
                              const dlong offset,
                              @ restrict const dfloat *x,
                              @ restrict const dfloat *y,
                              @ restrict const dfloat *z,
                              @ restrict dfloat *W)
{
  for (dlong n = 0; n < Ntotal; ++n; @tile(p_blockSize, @outer, @inner)) {
    const dfloat xc = (x[n] - p_pi);
    const dfloat yc = (y[n] - p_pi);
    const dfloat rc = sqrt(xc * xc + yc * yc);
    const dfloat thv = atan2(yc, xc);
    W[n + 0 * offset] = p_omega * rc * sin(thv);
    W[n + 1 * offset] = -p_omega * rc * cos(thv);
    W[n + 2 * offset] = 0.0;
  }
}

#endif

void UDF_LoadKernels(occa::properties &kernelInfo)
{
  kernelInfo["defines/p_pi"] = M_PI;
  kernelInfo["defines/p_omega"] = P_OMEGA;
  kernelInfo["defines/p_U0"] = P_U0;
  kernelInfo["defines/p_V0"] = P_V0;

  dfloat viscosity;
  platform->options.getArgs("VISCOSITY", viscosity);
  kernelInfo["defines/p_visc"] = viscosity;
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  options.getArgs("CI-MODE", ciMode);
  if (ciMode) {
    ciSetup(comm, options);
  }
  dfloat viscosity;
  options.getArgs("VISCOSITY", viscosity);

  platform->par->extract("casedata", "p_u0", P_U0);
  platform->par->extract("casedata", "p_v0", P_V0);
  platform->par->extract("casedata", "p_omega", P_OMEGA);
  platform->par->extract("casedata", "p_scale", P_SCALE);
  P_OMEGA *= M_PI;
  P_SCALE *= M_PI;

  if (platform->options.compareArgs("BUILD ONLY", "FALSE")) {
    double *const nek_cb_scnrs = (double *)nek::ptr("cb_scnrs");
    nek_cb_scnrs[0] = P_U0;
    nek_cb_scnrs[1] = P_V0;
    nek_cb_scnrs[2] = P_OMEGA;
    nek_cb_scnrs[3] = viscosity;
    nek_cb_scnrs[4] = P_SCALE;
  }
}

int timeStepConverged(nrs_t *nrs, int stage)
{
  if (nrs->neknek->nEXT() == 1) {
    return 1;
  }

  // do one corrector step
  return stage > 1;
}

void userq(nrs_t *nrs, double time, occa::memory o_S, occa::memory o_FS)
{
  auto mesh = nrs->meshV;
  dpdx(mesh->Nlocal, time, mesh->o_x, mesh->o_y, mesh->o_z, o_FS);
}

void UDF_Setup(nrs_t *nrs)
{
  udf.timeStepConverged = timeStepConverged;
  udf.sEqnSource = &userq;
}

void UDF_ExecuteStep(nrs_t *nrs, double time, int tstep)
{

  auto *mesh = nrs->meshV;
  if (platform->options.compareArgs("MOVING MESH", "TRUE")) {
    userMeshVelocity(mesh->Nlocal, nrs->fieldOffset, mesh->o_x, mesh->o_y, mesh->o_z, mesh->o_U);
  }

  constexpr int nStepAnalytical = 5;
  if (tstep <= nStepAnalytical) {
    exactUVW(mesh->Nlocal, nrs->fieldOffset, time, mesh->o_x, mesh->o_y, mesh->o_z, nrs->o_U);
    nrs->cds->o_S.copyFrom(nrs->o_U, nrs->fieldOffset);
  }

  auto o_Uexact = platform->o_memPool.reserve<dfloat>(nrs->NVfields * nrs->fieldOffset);
  auto o_Sexact = platform->o_memPool.reserve<dfloat>(nrs->fieldOffset);
  exactUVW(mesh->Nlocal, nrs->fieldOffset, time, mesh->o_x, mesh->o_y, mesh->o_z, o_Uexact);
  o_Sexact.copyFrom(o_Uexact, nrs->fieldOffset);

  platform->linAlg->axpbyMany(mesh->Nlocal, nrs->NVfields, nrs->fieldOffset, 1.0, nrs->o_U, -1.0, o_Uexact);
  platform->linAlg->axpby(mesh->Nlocal, 1.0, nrs->cds->o_S, -1.0, o_Sexact);

  auto o_UerrX = o_Uexact + 0 * nrs->fieldOffset;
  auto o_UerrY = o_Uexact + 1 * nrs->fieldOffset;
  auto o_UerrZ = o_Uexact + 2 * nrs->fieldOffset;

  platform->linAlg->abs(mesh->Nlocal, o_UerrX);
  platform->linAlg->abs(mesh->Nlocal, o_UerrY);
  platform->linAlg->abs(mesh->Nlocal, o_UerrZ);
  platform->linAlg->abs(mesh->Nlocal, o_Sexact);

  const auto LinfUx = platform->linAlg->max(mesh->Nlocal, o_UerrX, platform->comm.mpiCommParent);
  const auto LinfUy = platform->linAlg->max(mesh->Nlocal, o_UerrY, platform->comm.mpiCommParent);
  const auto LinfUz = platform->linAlg->max(mesh->Nlocal, o_UerrZ, platform->comm.mpiCommParent);
  const auto LinfS = platform->linAlg->max(mesh->Nlocal, o_Sexact, platform->comm.mpiCommParent);

  if (platform->comm.mpiRank == 0) {
    printf("LinfUx = %g, LinfUy = %g, LinfUz = %g, LinfS = %g\n", LinfUx, LinfUy, LinfUz, LinfS);
  }

  if (ciMode) {
    ciTestErrors(nrs, time, tstep);
  }
}
