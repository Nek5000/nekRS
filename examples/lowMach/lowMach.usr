C Linearized Model problem described in Ananias G. Tomboulides et. al
C JCP 146, CP986079, 1998

#include "casedata.h"

c-----------------------------------------------------------------------
      SUBROUTINE USERCHK

      INCLUDE 'SIZE'
      INCLUDE 'TOTAL'

      COMMON /SCRNS/ w1     (LX1,LY1,LZ1,LELT)
     $              ,T_err  (LX1,LY1,LZ1,LELT)
     $              ,VX_err (LX1,LY1,LZ1,LELT)
     $              ,QTL_err (LX1,LY1,LZ1,LELT)
      real w1,T_err,VX_err,QTL_err

      integer i,j,k,iel,ntot

      real glsc3,glmax

      real sumqw,l2_err,exact,max_err,XD,sech

      ntot = nx1*ny1*nz1*nelv

c      if(istep.lt.1) return

      do 100 iel=1,nelv
      do 100 k=1,nz1
      do 100 j=1,ny1
      do 100 i=1,nx1
         XD = XM1(i,j,k,iel)/DELTA
         sech = 1.0/cosh(XD)
         exact = 0.5*(3.0 + tanh(XD))
         VX_err(i,j,k,iel)  = abs(VX (i,j,k,iel  ) - exact) 
         T_err(i,j,k,iel)   = abs(T (i,j,k,iel,1) - exact) 
         QTL_err(i,j,k,iel) = abs(QTL(i,j,k,iel) - 
     &                            0.5/DELTA*(1. - (tanh(XD)*tanh(XD))))
 100  continue 
  
      max_err = glmax(VX_err,ntot)
      l2_err  = glsc3(VX_err,bm1,VX_err,ntot)/VOLVM1
      if (l2_err.gt.0) l2_err = sqrt(l2_err)
      if(nid.eq.0)
     & write(6,1) istep,time,max_err,l2_err
    1 format(i8,1p3e12.4,' ERROR VX: MAX/L2')

      max_err = glmax(T_err,ntot)
      l2_err  = glsc3(T_err,bm1,T_err,ntot)/VOLVM1
      if (l2_err.gt.0) l2_err = sqrt(l2_err)
      if(nid.eq.0)
     & write(6,2) istep,time,max_err,l2_err
    2 format(i8,1p3e12.4,' ERROR T: MAX/L2')

      max_err = glmax(QTL_err,ntot)
      l2_err  = glsc3(QTL_err,bm1,QTL_err,ntot)/VOLVM1
      if (l2_err.gt.0) l2_err = sqrt(l2_err)
      if(nid.eq.0)
     & write(6,3) istep,time,max_err,l2_err
    3 format(i8,1p3e12.4,' ERROR QTL: MAX/L2')


      RETURN
      END
C-----------------------------------------------------------------------
      SUBROUTINE USERIC (IX,IY,IZ,ieg)

C   Set initial conditions

      integer ix,iy,iz,ieg

      INCLUDE 'SIZE'
      INCLUDE 'TSTEP'
      INCLUDE 'NEKUSE'

      real xd

      XD = X/DELTA

      UX = 0.5*(3.0 + tanh(XD))
      UY = 0.0
      UZ = 0.0

      TEMP = 0.5*(3.0 + tanh(XD))

      RETURN
      END
C-----------------------------------------------------------------------
      subroutine usrdat

      return
      end
C-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'

      call rescale_x(xm1,-1.0,1.0)
      call rescale_x(ym1,0.0,1.0)
      call rescale_x(zm1,0.0,0.1)

      do iel=1,nelt
      do ifc=1,2*ndim
         if (cbc(ifc,iel,1) .eq. 'v  ') boundaryID(ifc,iel) = 1
         if (cbc(ifc,iel,1) .eq. 'O  ') boundaryID(ifc,iel) = 2
         if (cbc(ifc,iel,1) .eq. 'P  ') cbc(ifc,iel,2) = 'P  ' 
      enddo
      enddo

      do iel=1,nelt
      do ifc=5,6
         cbc(ifc,iel,1) = 'P  ' ! required for kludge (see below)
         cbc(ifc,iel,2) = 'P  ' ! required for kludge (see below)
      enddo
      enddo

      return
      end
C-----------------------------------------------------------------------
      subroutine usrdat3

      return
      end
C-----------------------------------------------------------------------
      subroutine usrsetvert(glo_num,nel,nx,ny,nz) ! to modify glo_num
      integer*8 glo_num(1)
  
      ! kludge for periodic bc in z
      nxy  = nx*ny
      nxyz = nx*ny*nz
      do iel = 1,nel
         ioff = nxyz*(iel-1)
         do ixy = 1,nxy
            glo_num(ioff + nxy*(nz-1) + ixy) = glo_num(ioff + ixy)
         enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
