#if p_knl == 0
// original kernel
@kernel void ellipticPartialAxCoeffHex3D_v0(const dlong Nelements,
                                       const dlong offset,
                                       const dlong loffset,
                                       @ restrict const dlong *elementList,
                                       @ restrict const dfloat *ggeo,
                                       @ restrict const dfloat *D,
                                       @ restrict const dfloat *S,
                                       @ restrict const dfloat *lambda0,
                                       @ restrict const dfloat *lambda1,
                                       @ restrict const dfloat *q,
                                       @ restrict dfloat *Aq)
{
  for (dlong e = 0; e < Nelements; ++e; @outer(0)) {

#if defined(FP32) && defined(gfxXX)
    @shared dfloat s_D[p_Nq][p_Nq];
#elif (p_Nq % 2 == 0)
    @shared dfloat s_D[p_Nq][p_Nq + 1];
#else
    @shared dfloat s_D[p_Nq][p_Nq];
#endif
    @shared dfloat s_q[p_Nq][p_Nq];

    @shared dfloat s_Gqr[p_Nq][p_Nq];
    @shared dfloat s_Gqs[p_Nq][p_Nq];

    @exclusive dfloat r_qt, r_Gqt, r_Auk;
    @exclusive dfloat r_q[p_Nq];
    @exclusive dfloat r_Aq[p_Nq];

    @exclusive dlong element;

    @exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
#ifndef p_poisson
    @exclusive dfloat r_GwJ;
#endif

    for (int j = 0; j < p_Nq; ++j; @inner(1))
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
        s_D[j][i] = D[p_Nq * j + i];
        element = elementList[e];
      }

    @barrier();

    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          const dlong base = i + j * p_Nq + element * p_Np;
          r_q[k] = q[base + k * p_Nq * p_Nq];
          r_Aq[k] = 0;
        }
      }
    }

    @barrier();

#pragma unroll p_Nq
    for (int k = 0; k < p_Nq; k++) {
      @barrier();
      for (int j = 0; j < p_Nq; ++j; @inner(1))
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

          r_G00 = ggeo[gbase + p_G00ID * p_Np];
          r_G01 = ggeo[gbase + p_G01ID * p_Np];
          r_G02 = ggeo[gbase + p_G02ID * p_Np];

          r_G11 = ggeo[gbase + p_G11ID * p_Np];
          r_G12 = ggeo[gbase + p_G12ID * p_Np];
          r_G22 = ggeo[gbase + p_G22ID * p_Np];

#ifndef p_poisson
          r_GwJ = ggeo[gbase + p_GWJID * p_Np];
#endif
        }

      @barrier();

      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          s_q[j][i] = r_q[k];

          r_qt = 0;

#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++)
            r_qt += s_D[k][m] * r_q[m];
        }
      }

      @barrier();

      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          dfloat qr = 0;
          dfloat qs = 0;

#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++) {
            qr += s_D[i][m] * s_q[j][m];
            qs += s_D[j][m] * s_q[m][i];
          }

          const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          const dfloat lbda0 = lambda0[p_lambda*id + 0 * loffset];
          s_Gqs[j][i] = lbda0 * (r_G01 * qr + r_G11 * qs + r_G12 * r_qt);
          s_Gqr[j][i] = lbda0 * (r_G00 * qr + r_G01 * qs + r_G02 * r_qt);
          r_Gqt = lbda0 * (r_G02 * qr + r_G12 * qs + r_G22 * r_qt);
#ifdef p_poisson
          r_Auk = 0.0;
#else
          r_Auk = r_GwJ * lambda1[p_lambda*id + 0 * loffset] * r_q[k];
#endif
        }
      }

      @barrier();

      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++) {
            r_Auk += s_D[m][j] * s_Gqs[m][i];
            r_Aq[m] += s_D[k][m] * r_Gqt;
            r_Auk += s_D[m][i] * s_Gqr[j][m];
          }

          r_Aq[k] += r_Auk;
        }
      }
    }

    @barrier();

    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          Aq[id] = r_Aq[k];
        }
      }
    }
  }
}

#endif

// padding for bank conflicts
#if p_Nq == 16
#define p_pad 1
#else
#define p_pad 0
#endif

#if p_Nq == 16 || p_Nq == 14 || p_Nq == 12 || p_Nq == 10 || p_Nq == 8 || p_Nq == 6 || p_Nq == 4
#define p_pad 0
#else
#define p_pad 1
#endif

#if p_knl == 1
@kernel void ellipticPartialAxCoeffHex3D_v1(const dlong Nelements,
                                       const dlong offset,
                                       const dlong loffset,
                                       @ restrict const dlong *elementList,
                                       @ restrict const dfloat *ggeo,
                                       @ restrict const dfloat *D,
                                       @ restrict const dfloat *S,
                                       @ restrict const dfloat *lambda0,
                                       @ restrict const dfloat *lambda1,
                                       @ restrict const dfloat *q,
                                       @ restrict dfloat *Aq)
{

  for (dlong e = 0; e < Nelements; e++; @outer(0)) {

    @shared dfloat s_D[p_Nq][p_Nq + p_pad];
    @shared dfloat s_q[p_Nq][p_Nq + p_pad];
    @shared dfloat s_v[p_Nq][p_Nq + p_pad];
    @shared dfloat s_w[p_Nq][p_Nq + p_pad];

    @exclusive dfloat r_GDut, r_Auk;

    // register array to hold u(i,j,0:N) private to thread
    @exclusive dfloat r_u[p_Nq];
    // array for results Au(i,j,0:N)
    @exclusive dfloat r_Au[p_Nq];

    @exclusive dlong element;

    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {

        // load D into local memory
        //  s_D[i][j] = d \phi_i at node j
        s_D[j][i] = D[p_Nq * j + i]; // D is column major

        element = elementList[e];

        const dlong base = i + j * p_Nq + element * p_Np;

// load pencil of u into register
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          const dlong id = base + k * p_Nq * p_Nq;
          r_u[k] = (id != -1) ? q[id] : 0.0;
        }

#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          r_Au[k] = 0.0;
        }
      }
    }

    // Layer by layer
#ifdef smXX
// only force some type of unrolling in CUDA mode
#pragma unroll p_Nq
#endif
    for (int k = 0; k < p_Nq; k++) {
      @barrier();

      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          // share u(:,:,k)
          s_q[j][i] = r_u[k];
        }
      }
      @barrier();

      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          // prefetch geometric factors
          const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

          const dfloat r_G00 = ggeo[gbase + p_G00ID * p_Np];
          const dfloat r_G01 = ggeo[gbase + p_G01ID * p_Np];
          const dfloat r_G02 = ggeo[gbase + p_G02ID * p_Np];

          const dfloat r_G11 = ggeo[gbase + p_G11ID * p_Np];
          const dfloat r_G12 = ggeo[gbase + p_G12ID * p_Np];
          const dfloat r_G22 = ggeo[gbase + p_G22ID * p_Np];

#ifndef p_poisson
          const dfloat r_GwJ = ggeo[gbase + p_GWJID * p_Np];
#endif

          dfloat ur = 0.f;
          dfloat us = 0.f;
          dfloat ut = 0;

#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++) {
            ut += s_D[k][m] * r_u[m];
          }

#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++) {
            ur += s_D[i][m] * s_q[j][m];
            us += s_D[j][m] * s_q[m][i];
          }

          const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          const dfloat lbda0 = lambda0[p_lambda*id + 0 * loffset];

          s_w[j][i] = lbda0 * (r_G01 * ur + r_G11 * us + r_G12 * ut);
          s_v[j][i] = lbda0 * (r_G00 * ur + r_G01 * us + r_G02 * ut);
          r_GDut = lbda0 * (r_G02 * ur + r_G12 * us + r_G22 * ut);
#ifdef p_poisson
          r_Auk = 0.0;
#else
          r_Auk = r_GwJ * lambda1[p_lambda*id + 0 * loffset] * r_u[k];
#endif
        }
      }

      @barrier();

      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {

#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++) {
            r_Au[m] += s_D[k][m] * r_GDut;
          }

#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++) {
            r_Auk += s_D[m][j] * s_w[m][i];
            r_Auk += s_D[m][i] * s_v[j][m];
          }

          r_Au[k] += r_Auk;
        }
      }
    } // end Layer by layer

    @barrier();

    // write out
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
        const dlong id = element * p_Np + j * p_Nq + i;

#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          Aq[id + k * p_Nq * p_Nq] = r_Au[k];
        }
      }
    }
  }
}
#endif

#if defined(FP32)
#if p_Nq == 2
#define p_NelementsPerBlk 63
#elif p_Nq == 3
#define p_NelementsPerBlk 27
#elif p_Nq == 4
#define p_NelementsPerBlk 15
#elif p_Nq == 5
#define p_NelementsPerBlk 9
#elif p_Nq == 6
#define p_NelementsPerBlk 7
#elif p_Nq == 7
#define p_NelementsPerBlk 5
#elif p_Nq == 8
#define p_NelementsPerBlk 5
#elif p_Nq == 9
#define p_NelementsPerBlk 3
#elif p_Nq == 10
#define p_NelementsPerBlk 5
#elif p_Nq == 11
#define p_NelementsPerBlk 3
#elif p_Nq == 12
#define p_NelementsPerBlk 3
#elif p_Nq == 13
#define p_NelementsPerBlk 3
#elif p_Nq == 14
#define p_NelementsPerBlk 3
#elif p_Nq == 15
#define p_NelementsPerBlk 3
#else
#define p_NelementsPerBlk 1
#endif

#else

// 2D, blocked version
#if p_N == 1
#define p_NelementsPerBlk 16
#elif p_N == 2
#define p_NelementsPerBlk 56
#elif p_N == 3
#define p_NelementsPerBlk 32
#elif p_N == 4
#define p_NelementsPerBlk 5
#elif p_N == 5
#define p_NelementsPerBlk 1
#elif p_N == 6
#define p_NelementsPerBlk 5
#elif p_N == 7
#define p_NelementsPerBlk 1
#elif p_N == 8
#define p_NelementsPerBlk 3
#elif p_N == 9
#define p_NelementsPerBlk 1
#elif p_N == 10
#define p_NelementsPerBlk 1
#elif p_N == 11
#define p_NelementsPerBlk 1
#elif p_N == 12
#define p_NelementsPerBlk 1
#elif p_N == 13
#define p_NelementsPerBlk 1
#elif p_N == 14
#define p_NelementsPerBlk 1
#elif p_N == 15
#define p_NelementsPerBlk 1
#else
#define p_NelementsPerBlk 1
#endif

#endif

// padding for bank conflicts
#if p_Nq == 16
#define p_pad 1
#else
#define p_pad 0
#endif

#if p_knl == 2

@kernel void ellipticPartialAxCoeffHex3D_v2(const dlong Nelements,
                                       const dlong offset,
                                       const dlong loffset,
                                       @ restrict const dlong *elementList,
                                       @ restrict const dfloat *ggeo,
                                       @ restrict const dfloat *D,
                                       @ restrict const dfloat *S,
                                       @ restrict const dfloat *lambda0,
                                       @ restrict const dfloat *lambda1,
                                       @ restrict const dfloat *q,
                                       @ restrict dfloat *Aq)
{

  for (dlong eo = 0; eo < Nelements; eo += p_NelementsPerBlk; @outer(0)) {

    @shared dfloat s_D[p_Nq][p_Nq + p_pad];
    @shared dfloat s_q[p_NelementsPerBlk][p_Nq][p_Nq + p_pad];
    @shared dfloat s_v[p_NelementsPerBlk][p_Nq][p_Nq + p_pad];
    @shared dfloat s_w[p_NelementsPerBlk][p_Nq][p_Nq + p_pad];

    @exclusive dfloat r_GDut, r_Auk;

    // register array to hold u(i,j,0:N) private to thread
    @exclusive dfloat r_u[p_Nq];
    // array for results Au(i,j,0:N)
    @exclusive dfloat r_Au[p_Nq];

    @exclusive dlong r_e, element;

    for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {

          // load D into local memory
          //  s_D[i][j] = d \phi_i at node j
          if (es == 0) {
            s_D[j][i] = D[p_Nq * j + i]; // D is column major
          }

          r_e = es + eo;

          if (r_e < Nelements) {
            element = elementList[r_e];

            const dlong base = i + j * p_Nq + element * p_Np;

// load pencil of u into register
#pragma unroll p_Nq
            for (int k = 0; k < p_Nq; k++) {
              const dlong id = base + k * p_Nq * p_Nq;
              r_u[k] = (id != -1) ? q[id] : 0.0;
            }

#pragma unroll p_Nq
            for (int k = 0; k < p_Nq; k++) {
              r_Au[k] = 0.0;
            }
          }
        }
      }
    }

    // Layer by layer
#ifdef smXX
// only force some type of unrolling in CUDA mode
#pragma unroll p_Nq
#endif
#ifdef gfxXX
// on HIP, tell the compiler to not unroll this loop
#pragma nounroll
#endif
    for (int k = 0; k < p_Nq; k++) {
      @barrier();

      for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
        for (int j = 0; j < p_Nq; ++j; @inner(1)) {
          for (int i = 0; i < p_Nq; ++i; @inner(0)) {
            // share u(:,:,k)
            s_q[es][j][i] = r_u[k];
          }
        }
      }

      @barrier();

      for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
        for (int j = 0; j < p_Nq; ++j; @inner(1)) {
          for (int i = 0; i < p_Nq; ++i; @inner(0)) {

            dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
#ifndef p_poisson
            dfloat r_GwJ;
            dfloat lbda1;
#endif
            dfloat lbda0;

            if (r_e < Nelements) {
              // prefetch geometric factors
              const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

              r_G00 = ggeo[gbase + p_G00ID * p_Np];
              r_G01 = ggeo[gbase + p_G01ID * p_Np];
              r_G02 = ggeo[gbase + p_G02ID * p_Np];

              r_G11 = ggeo[gbase + p_G11ID * p_Np];
              r_G12 = ggeo[gbase + p_G12ID * p_Np];
              r_G22 = ggeo[gbase + p_G22ID * p_Np];

              const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
              lbda0 = lambda0[p_lambda*id + 0 * loffset];
#ifndef p_poisson
              r_GwJ = ggeo[gbase + p_GWJID * p_Np];
              lbda1 = lambda1[p_lambda*id + 0 * loffset];
#endif
            }

            dfloat ur = 0.f;
            dfloat us = 0.f;
            dfloat ut = 0;

#pragma unroll p_Nq
            for (int m = 0; m < p_Nq; m++) {
              ut += s_D[k][m] * r_u[m];
            }

#pragma unroll p_Nq
            for (int m = 0; m < p_Nq; m++) {
              ur += s_D[i][m] * s_q[es][j][m];
              us += s_D[j][m] * s_q[es][m][i];
            }

            s_w[es][j][i] = lbda0 * (r_G01 * ur + r_G11 * us + r_G12 * ut);
            s_v[es][j][i] = lbda0 * (r_G00 * ur + r_G01 * us + r_G02 * ut);
            r_GDut = lbda0 * (r_G02 * ur + r_G12 * us + r_G22 * ut);

#ifdef p_poisson
            r_Auk = 0.0;
#else
            r_Auk = r_GwJ * lbda1 * r_u[k];
#endif
          }
        }
      }

      @barrier();

      for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
        for (int j = 0; j < p_Nq; ++j; @inner(1)) {
          for (int i = 0; i < p_Nq; ++i; @inner(0)) {

#pragma unroll p_Nq
            for (int m = 0; m < p_Nq; m++) {
              r_Au[m] += s_D[k][m] * r_GDut;
            }

#pragma unroll p_Nq
            for (int m = 0; m < p_Nq; m++) {
              r_Auk += s_D[m][j] * s_w[es][m][i];
              r_Auk += s_D[m][i] * s_v[es][j][m];
            }

            r_Au[k] += r_Auk;
          }
        }
      }
    } // end Layer by layer

    @barrier();

    // write out
    for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          if (r_e < Nelements) {
            const dlong id = element * p_Np + j * p_Nq + i;

#pragma unroll p_Nq
            for (int k = 0; k < p_Nq; k++) {
              Aq[id + k * p_Nq * p_Nq] = r_Au[k];
            }
          }
        }
      }
    }
  }
}
#endif

// 3D thread structure, good for low orders
#if p_Nq < 11

#if defined(FP32)
#if p_Nq == 2
#define p_NelementsPerBlk 27
#elif p_Nq == 3
#define p_NelementsPerBlk 15
#elif p_Nq == 4
#define p_NelementsPerBlk 15
#elif p_Nq == 5
#define p_NelementsPerBlk 8
#elif p_Nq == 6
#define p_NelementsPerBlk 4
#elif p_Nq == 7
#define p_NelementsPerBlk 2
#elif p_Nq == 8
#define p_NelementsPerBlk 2
#else
#define p_NelementsPerBlk 1
#endif

#else

#if p_N == 1
#define p_NelementsPerBlk 8
#elif p_N == 2
#define p_NelementsPerBlk 4
#elif p_N == 3
#define p_NelementsPerBlk 2
#elif p_N == 4
#define p_NelementsPerBlk 1
#elif p_N == 5
#define p_NelementsPerBlk 1
#elif p_N == 6
#define p_NelementsPerBlk 1
#elif p_N == 7
#define p_NelementsPerBlk 1
#else
#define p_NelementsPerBlk 1
#endif

#endif

#if p_knl == 3
@kernel void ellipticPartialAxCoeffHex3D_v3(const dlong Nelements,
                                       const dlong offset,
                                       const dlong loffset,
                                       @ restrict const dlong *elementList,
                                       @ restrict const dfloat *ggeo,
                                       @ restrict const dfloat *D,
                                       @ restrict const dfloat *S,
                                       @ restrict const dfloat *lambda0,
                                       @ restrict const dfloat *lambda1,
                                       @ restrict const dfloat *q,
                                       @ restrict dfloat *Aq)
{
// padding for bank conflicts
#if (p_Nq == 8 || p_Nq == 4) && defined(smXX)
#define p_pad 1
#else
#define p_pad 0
#endif

#if p_Nq == 16 || p_Nq == 14 || p_Nq == 12 || p_Nq == 8 || p_Nq == 6 || p_Nq == 4
#define p_pad 0
#else
#define p_pad 1
#endif

  for (int eo = 0; eo < Nelements; eo += p_NelementsPerBlk; @outer(0)) {

    @shared dfloat s_D[p_Nq][p_Nq + p_pad];
    @shared dfloat s_DT[p_Nq][p_Nq + p_pad];
    @shared dfloat s_q[p_NelementsPerBlk][p_Nq][p_Nq][p_Nq + p_pad];
    @shared dfloat s_Gqr[p_NelementsPerBlk][p_Nq][p_Nq][p_Nq + p_pad];
    @shared dfloat s_Gqs[p_NelementsPerBlk][p_Nq][p_Nq][p_Nq + p_pad];
    @shared dfloat s_Gqt[p_NelementsPerBlk][p_Nq][p_Nq][p_Nq + p_pad];

    @exclusive dlong element;
#ifndef p_poisson
    @exclusive dfloat r_wJ;
#endif

    @exclusive int k, es;

    for (int ke = 0; ke < p_Nq * p_NelementsPerBlk; ++ke; @inner(2)) {
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {

          // load operators
          if (ke == 0) {
            const int id = j * p_Nq + i;
            const dfloat Dji = D[id];
            s_D[j][i] = Dji;
            s_DT[i][j] = Dji;
          }

          k = ke % p_Nq;
          es = ke / p_Nq;
          dlong r_e = es + eo;
          element = (r_e < Nelements) ? elementList[r_e] : -1;
          if (element != -1) {
            const dlong id = i + j * p_Nq + k * p_Nq * p_Nq + element * p_Np;
            if (id != -1)
              s_q[es][k][j][i] = q[id];
            else
              s_q[es][k][j][i] = 0.0;
          }
        }
      }
    }

    @barrier();

    for (int ke = 0; ke < p_Nq * p_NelementsPerBlk; ++ke; @inner(2)) {
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {

          if (element != -1) {

            // 't' terms
            dfloat tmp = 0.0;

            const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

            const dfloat G00 = ggeo[gbase + p_G00ID * p_Np];
            const dfloat G01 = ggeo[gbase + p_G01ID * p_Np];
            const dfloat G02 = ggeo[gbase + p_G02ID * p_Np];

            const dfloat G11 = ggeo[gbase + p_G11ID * p_Np];
            const dfloat G12 = ggeo[gbase + p_G12ID * p_Np];
            const dfloat G22 = ggeo[gbase + p_G22ID * p_Np];

#ifndef p_poisson
            r_wJ = ggeo[gbase + p_GWJID * p_Np];
#endif

            // #pragma unroll p_Unr
            for (int m = 0; m < p_Nq; ++m) {
              const dfloat pmji = s_q[es][m][j][i];
              const dfloat Dkm = s_DT[m][k];
              tmp += Dkm * pmji;
            }

            s_Gqr[es][k][j][i] = G02 * tmp;
            s_Gqs[es][k][j][i] = G12 * tmp;
            s_Gqt[es][k][j][i] = G22 * tmp;

            // 'r' terms
            tmp = 0;
            // #pragma unroll p_Unr
            for (int m = 0; m < p_Nq; ++m) {
              const dfloat Dim = s_D[i][m];
              tmp += Dim * s_q[es][k][j][m];
            }

            s_Gqr[es][k][j][i] += G00 * tmp;
            s_Gqs[es][k][j][i] += G01 * tmp;
            s_Gqt[es][k][j][i] += G02 * tmp;

            // 's' terms
            tmp = 0;
            // #pragma unroll p_Unr
            for (int m = 0; m < p_Nq; ++m) {
              const dfloat Djm = s_D[j][m];
              tmp += Djm * s_q[es][k][m][i];
            }

            const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
            s_Gqr[es][k][j][i] += G01 * tmp;
            s_Gqs[es][k][j][i] += G11 * tmp;
            s_Gqt[es][k][j][i] += lambda0[p_lambda*id + 0 * loffset] * G12 * tmp;
          }
        }
      }
    }

    @barrier();

    for (int ke = 0; ke < p_Nq * p_NelementsPerBlk; ++ke; @inner(2)) {
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {

          if (element != -1) {
#ifdef p_poisson
            dfloat tmpAp = 0.0;
#else
            const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
            dfloat tmpAp = s_q[es][k][j][i] * lambda1[p_lambda*id + 0 * loffset] * r_wJ;
#endif

            // use same matrix for both slices
            // #pragma unroll p_Unr
            for (int m = 0; m < p_Nq; ++m) {
              const dfloat Dmi = s_D[m][i];
              const dfloat Dmj = s_D[m][j];

              tmpAp += Dmi * s_Gqr[es][k][j][m];
              tmpAp += Dmj * s_Gqs[es][k][m][i];
            }

            // #pragma unroll p_Unr
            for (int m = 0; m < p_Nq; ++m) {
              const dfloat Gpt = s_Gqt[es][m][j][i];
              const dfloat Dmk = s_D[m][k];
              tmpAp += Dmk * Gpt;
            }

            const dlong base = i + j * p_Nq + k * p_Nq * p_Nq + element * p_Np;
            Aq[base] = tmpAp;
          }
        }
      }
    }
  }
}
#endif
#endif

// padding for bank conflicts
#if p_Nq == 16
#define p_pad 1
#else
#define p_pad 0
#endif

#if p_Nq == 3
#define p_NelementsPerBlk 31
#define p_pad 1
#elif p_Nq == 4
#define p_NelementsPerBlk 31
#elif p_Nq == 5
#define p_NelementsPerBlk 19
#define p_pad 1
#elif p_Nq == 6
#define p_NelementsPerBlk 7
#elif p_Nq == 7
#define p_NelementsPerBlk 5
#define p_pad 1
#elif p_Nq == 8
#define p_NelementsPerBlk 3
#elif p_Nq == 9
#define p_NelementsPerBlk 5
#define p_pad 1
#elif p_Nq == 10
#define p_NelementsPerBlk 3
#elif p_Nq == 11
#define p_NelementsPerBlk 2
#define p_pad 1
#elif p_Nq == 12
#define p_NelementsPerBlk 3
#elif p_Nq == 13
#define p_NelementsPerBlk 3
#define p_pad 1
#elif p_Nq == 14
#define p_NelementsPerBlk 3
#elif p_Nq == 15
#define p_NelementsPerBlk 1
#else
#define p_NelementsPerBlk 1
#endif

#if p_knl == 4
@kernel void ellipticPartialAxCoeffHex3D_v4(const dlong Nelements,
                                       const dlong offset,
                                       const dlong loffset,
                                       @ restrict const dlong *elementList,
                                       @ restrict const dfloat *ggeo,
                                       @ restrict const dfloat *D,
                                       @ restrict const dfloat *S,
                                       @ restrict const dfloat *lambda0,
                                       @ restrict const dfloat *lambda1,
                                       @ restrict const dfloat *q,
                                       @ restrict dfloat *Aq)
{

  for (dlong eo = 0; eo < Nelements; eo += p_NelementsPerBlk; @outer(0)) {

    @shared dfloat s_D[p_Nq][p_Nq + p_pad];
    @shared dfloat s_q[p_Nq][p_Nq][p_NelementsPerBlk];
    @shared dfloat s_v[p_Nq][p_Nq][p_NelementsPerBlk];
    @shared dfloat s_w[p_Nq][p_Nq][p_NelementsPerBlk];

    @exclusive dfloat r_Auk;

    // register array to hold u(i,j,0:N) private to thread
    @exclusive dfloat r_u[p_Nq];
    // array for results Au(i,j,0:N)
    @exclusive dfloat r_Au[p_Nq];

    @exclusive dlong r_e, element;

    for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {

          // load D into local memory
          //  s_D[i][j] = d \phi_i at node j
          if (es == 0) {
            s_D[j][i] = D[p_Nq * j + i]; // D is column major
          }

          r_e = es + eo;

          if (r_e < Nelements) {
            element = elementList[r_e];

            const dlong base = i + j * p_Nq + element * p_Np;

            // load pencil of u into register
#pragma unroll p_Nq
            for (int k = 0; k < p_Nq; k++) {
              const dlong id = base + k * p_Nq * p_Nq;
              r_u[k] = (id != -1) ? q[id] : 0.0;
            }

#pragma unroll p_Nq
            for (int k = 0; k < p_Nq; k++) {
              r_Au[k] = 0.0;
            }
          }
        }
      }
    }

    // Layer by layer
#ifdef smXX
// only force some type of unrolling in CUDA mode
#pragma unroll p_Nq
#endif
#ifdef gfxXX
// on HIP, tell the compiler to not unroll this loop
#pragma nounroll
#endif
    for (int k = 0; k < p_Nq; k++) {

      @barrier();

      for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
        for (int j = 0; j < p_Nq; ++j; @inner(1)) {
          for (int i = 0; i < p_Nq; ++i; @inner(0)) {
            // share u(:,:,k)
            s_q[j][i][es] = r_u[k];
          }
        }
      }

      @barrier();

      for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
        for (int j = 0; j < p_Nq; ++j; @inner(1)) {
          for (int i = 0; i < p_Nq; ++i; @inner(0)) {

            dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
#ifndef p_poisson
            dfloat r_GwJ;
            dfloat lbda1;
#endif
            dfloat lbda0;

            if (r_e < Nelements) {
              // prefetch geometric factors
              const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

              r_G00 = ggeo[gbase + p_G00ID * p_Np];
              r_G01 = ggeo[gbase + p_G01ID * p_Np];
              r_G02 = ggeo[gbase + p_G02ID * p_Np];

              r_G11 = ggeo[gbase + p_G11ID * p_Np];
              r_G12 = ggeo[gbase + p_G12ID * p_Np];
              r_G22 = ggeo[gbase + p_G22ID * p_Np];

              const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
              lbda0 = lambda0[p_lambda*id + 0 * loffset];

#ifndef p_poisson
              lbda1 = lambda1[p_lambda*id + 0 * loffset];
              r_GwJ = ggeo[gbase + p_GWJID * p_Np];
#endif
            }

            dfloat ur = 0.f;
            dfloat us = 0.f;
            dfloat ut = 0;

#pragma unroll p_Nq
            for (int m = 0; m < p_Nq; m++) {
              ur += s_D[i][m] * s_q[j][m][es];
              us += s_D[j][m] * s_q[m][i][es];
            }

#pragma unroll p_Nq
            for (int m = 0; m < p_Nq; m++) {
              ut += s_D[k][m] * r_u[m];
            }

            s_w[j][i][es] = lbda0 * (r_G01 * ur + r_G11 * us + r_G12 * ut);
            s_v[j][i][es] = lbda0 * (r_G00 * ur + r_G01 * us + r_G02 * ut);
            dfloat r_GDut = lbda0 * (r_G02 * ur + r_G12 * us + r_G22 * ut);

#pragma unroll p_Nq
            for (int m = 0; m < p_Nq; m++) {
              r_Au[m] += s_D[k][m] * r_GDut;
            }

#ifdef p_poisson
            r_Auk = 0.0;
#else
            r_Auk = r_GwJ * lbda1 * r_u[k];
#endif
          }
        }
      }

      @barrier();

      for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
        for (int j = 0; j < p_Nq; ++j; @inner(1)) {
          for (int i = 0; i < p_Nq; ++i; @inner(0)) {

#pragma unroll p_Nq
            for (int m = 0; m < p_Nq; m++) {
              r_Auk += s_D[m][j] * s_w[m][i][es];
              r_Auk += s_D[m][i] * s_v[j][m][es];
            }

            r_Au[k] += r_Auk;
          }
        }
      }
    } // end Layer by layer

    @barrier();

    // write out
    for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          if (r_e < Nelements) {
            const dlong id = element * p_Np + j * p_Nq + i;

#pragma unroll p_Nq
            for (int k = 0; k < p_Nq; k++) {
              Aq[id + k * p_Nq * p_Nq] = r_Au[k];
            }
          }
        }
      }
    }
  }
}
#endif

#if p_knl == 5
@kernel void ellipticPartialAxCoeffHex3D_v5(const dlong Nelements,
                                       const dlong offset,
                                       const dlong loffset,
                                       @ restrict const dlong *elementList,
                                       @ restrict const dfloat *ggeo,
                                       @ restrict const dfloat *D,
                                       @ restrict const dfloat *S,
                                       @ restrict const dfloat *lambda0,
                                       @ restrict const dfloat *lambda1,
                                       @ restrict const dfloat *q,
                                       @ restrict dfloat *Aq)
{

  for (dlong eo = 0; eo < Nelements; eo += p_NelementsPerBlk; @outer(0)) {

    @shared dfloat s_D[p_Nq][p_Nq + p_pad];
    @shared dfloat s_q[p_Nq][p_Nq][p_NelementsPerBlk];
    @shared dfloat s_v[p_Nq][p_Nq][p_NelementsPerBlk];
    @shared dfloat s_w[p_Nq][p_Nq][p_NelementsPerBlk];

    @exclusive dfloat r_GDut, r_Auk;

    // register array to hold u(i,j,0:N) private to thread
    @exclusive dfloat r_u[p_Nq];
    // array for results Au(i,j,0:N)
    @exclusive dfloat r_Au[p_Nq];

    @exclusive dlong r_e, element;

    for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {

          // load D into local memory
          //  s_D[i][j] = d \phi_i at node j
          if (es == 0) {
            s_D[j][i] = D[p_Nq * j + i]; // D is column major
          }

          r_e = es + eo;

          if (r_e < Nelements) {
            element = elementList[r_e];

            const dlong base = i + j * p_Nq + element * p_Np;

// load pencil of u into register
#pragma unroll p_Nq
            for (int k = 0; k < p_Nq; k++) {
              const dlong id = base + k * p_Nq * p_Nq;
              r_u[k] = (id != -1) ? q[id] : 0.0;
            }

#pragma unroll p_Nq
            for (int k = 0; k < p_Nq; k++) {
              r_Au[k] = 0.0;
            }
          }
        }
      }
    }

    // Layer by layer
#ifdef smXX
// only force some type of unrolling in CUDA mode
#pragma unroll p_Nq
#endif
#ifdef gfxXX
// on HIP, tell the compiler to not unroll this loop
#pragma nounroll
#endif
    for (int k = 0; k < p_Nq; k++) {

      @barrier();

      for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
        for (int j = 0; j < p_Nq; ++j; @inner(1)) {
          for (int i = 0; i < p_Nq; ++i; @inner(0)) {
            // share u(:,:,k)
            s_q[j][i][es] = r_u[k];
          }
        }
      }

      @barrier();

      for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
        for (int j = 0; j < p_Nq; ++j; @inner(1)) {
          for (int i = 0; i < p_Nq; ++i; @inner(0)) {

            dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
#ifndef p_poisson
            dfloat r_GwJ;
            dfloat lbda1;
#endif
            dfloat lbda0;

            if (r_e < Nelements) {
              // prefetch geometric factors

              const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

              r_G00 = ggeo[gbase + p_G00ID * p_Np];
              r_G01 = ggeo[gbase + p_G01ID * p_Np];
              r_G02 = ggeo[gbase + p_G02ID * p_Np];

              r_G11 = ggeo[gbase + p_G11ID * p_Np];
              r_G12 = ggeo[gbase + p_G12ID * p_Np];
              r_G22 = ggeo[gbase + p_G22ID * p_Np];

              const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
              lbda0 = lambda0[p_lambda*id + 0 * loffset];
#ifndef p_poisson
              r_GwJ = ggeo[gbase + p_GWJID * p_Np];
              lbda1 = lambda1[p_lambda*id + 0 * loffset];
#endif
            }

            dfloat ur = 0.f;
            dfloat us = 0.f;
            dfloat ut = 0;

#pragma unroll p_Nq
            for (int m = 0; m < p_Nq; m++) {
              ur += s_D[i][m] * s_q[j][m][es];
              us += s_D[j][m] * s_q[m][i][es];
            }

#pragma unroll p_Nq
            for (int m = 0; m < p_Nq; m++) {
              ut += s_D[k][m] * r_u[m];
            }

            s_w[j][i][es] = lbda0 * (r_G01 * ur + r_G11 * us + r_G12 * ut);
            s_v[j][i][es] = lbda0 * (r_G00 * ur + r_G01 * us + r_G02 * ut);
            r_GDut = lbda0 * (r_G02 * ur + r_G12 * us + r_G22 * ut);

#pragma unroll p_Nq
            for (int m = 0; m < p_Nq; m++) {
              r_Au[m] += s_D[k][m] * r_GDut;
            }

#ifdef p_poisson
            r_Auk = 0.0;
#else
            r_Auk = r_GwJ * lbda1 * r_u[k];
#endif
          }
        }
      }

      @barrier();

      for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
        for (int j = 0; j < p_Nq; ++j; @inner(1)) {
          for (int i = 0; i < p_Nq; ++i; @inner(0)) {

#pragma unroll p_Nq
            for (int m = 0; m < p_Nq; m++) {
              r_Auk += s_D[m][j] * s_w[m][i][es];
              r_Auk += s_D[m][i] * s_v[j][m][es];
            }

            r_Au[k] += r_Auk;
          }
        }
      }
    } // end Layer by layer

    @barrier();

    // write out
    for (int es = 0; es < p_NelementsPerBlk; ++es; @inner(2)) {
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          if (r_e < Nelements) {
            const dlong id = element * p_Np + j * p_Nq + i;

#pragma unroll p_Nq
            for (int k = 0; k < p_Nq; k++) {
              Aq[id + k * p_Nq * p_Nq] = r_Au[k];
            }
          }
        }
      }
    }
  }
}
#endif

// padding for bank conflicts
#if p_Nq == 16
#define p_pad 1
#else
#define p_pad 0
#endif

#if p_Nq == 3
#define p_NelementsPerBlk 31
#define p_pad 1
#elif p_Nq == 4
#define p_NelementsPerBlk 31
#define p_pad 1
#elif p_Nq == 5
#define p_NelementsPerBlk 19
#define p_pad 1
#elif p_Nq == 6
#define p_NelementsPerBlk 7
#elif p_Nq == 7
#define p_NelementsPerBlk 5
#define p_pad 1
#elif p_Nq == 8
#define p_NelementsPerBlk 3
#elif p_Nq == 9
#define p_NelementsPerBlk 3
#define p_pad 1
#elif p_Nq == 10
#define p_NelementsPerBlk 3
#define p_pad 0
#elif p_Nq == 11
#define p_NelementsPerBlk 2
#define p_pad 1
#elif p_Nq == 12
#define p_NelementsPerBlk 3
#elif p_Nq == 13
#define p_NelementsPerBlk 3
#define p_pad 1
#elif p_Nq == 14
#define p_NelementsPerBlk 3
#elif p_Nq == 15
#define p_NelementsPerBlk 1
#else
#define p_NelementsPerBlk 1
#endif

// padding for bank conflicts
#if p_Nq == 16 || p_Nq == 14 || p_Nq == 12 || p_Nq == 10 || p_Nq == 8 || p_Nq == 6 || p_Nq == 4
#define p_pad 0
#else
#define p_pad 1
#endif

#if p_knl == 6
@kernel void ellipticPartialAxCoeffHex3D_v6(const dlong Nelements,
                                       const dlong offset,
                                       const dlong loffset,
                                       @ restrict const dlong *elementList,
                                       @ restrict const dfloat *ggeo,
                                       @ restrict const dfloat *D,
                                       @ restrict const dfloat *S,
                                       @ restrict const dfloat *lambda0,
                                       @ restrict const dfloat *lambda1,
                                       @ restrict const dfloat *q,
                                       @ restrict dfloat *Aq)
{

  for (dlong e = 0; e < Nelements; e++; @outer(0)) {

    @shared dfloat s_D[p_Nq][p_Nq + p_pad];
    @shared dfloat s_q[p_Nq][p_Nq + p_pad];
    @shared dfloat s_v[p_Nq][p_Nq + p_pad];
    @shared dfloat s_w[p_Nq][p_Nq + p_pad];

    @exclusive dfloat r_GDut, r_Auk;

    // register array to hold u(i,j,0:N) private to thread
    @exclusive dfloat r_u[p_Nq];
    // array for results Au(i,j,0:N)
    @exclusive dfloat r_Au[p_Nq];

    @exclusive dlong element;

    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {

        // load D into local memory
        //  s_D[i][j] = d \phi_i at node j
        s_D[j][i] = D[p_Nq * j + i]; // D is column major

        element = elementList[e];

        const dlong base = i + j * p_Nq + element * p_Np;

// load pencil of u into register
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          const dlong id = base + k * p_Nq * p_Nq;
          r_u[k] = (id != -1) ? q[id] : 0.0;
        }

#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          r_Au[k] = 0.0;
        }
      }
    }

    // Layer by layer
#ifdef smXX
// only force some type of unrolling in CUDA mode
#pragma unroll p_Nq
#endif
    for (int k = 0; k < p_Nq; k++) {

      @barrier();

      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          // share u(:,:,k)
          s_q[j][i] = r_u[k];
        }
      }

      @barrier();

      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {
          // prefetch geometric factors
          const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

          const dfloat r_G00 = ggeo[gbase + p_G00ID * p_Np];
          const dfloat r_G01 = ggeo[gbase + p_G01ID * p_Np];
          const dfloat r_G02 = ggeo[gbase + p_G02ID * p_Np];

          const dfloat r_G11 = ggeo[gbase + p_G11ID * p_Np];
          const dfloat r_G12 = ggeo[gbase + p_G12ID * p_Np];
          const dfloat r_G22 = ggeo[gbase + p_G22ID * p_Np];

#ifndef p_poisson
          const dfloat r_GwJ = ggeo[gbase + p_GWJID * p_Np];
#endif

          dfloat ur = 0.f;
          dfloat us = 0.f;
          dfloat ut = 0;

#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++) {
            ut += s_D[k][m] * r_u[m];
          }

#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++) {
            ur += s_D[i][m] * s_q[j][m];
            us += s_D[j][m] * s_q[m][i];
          }

          const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          const dfloat lbda0 = lambda0[p_lambda*id + 0 * loffset];

          s_w[j][i] = lbda0 * (r_G01 * ur + r_G11 * us + r_G12 * ut);
          s_v[j][i] = lbda0 * (r_G00 * ur + r_G01 * us + r_G02 * ut);
          r_GDut = lbda0 * (r_G02 * ur + r_G12 * us + r_G22 * ut);
#ifdef p_poisson
          r_Auk = 0.0;
#else
          r_Auk = r_GwJ * lambda1[p_lambda*id + 0 * loffset] * r_u[k];
#endif
        }
      }

      @barrier();

      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
        for (int i = 0; i < p_Nq; ++i; @inner(0)) {

#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++) {
            r_Au[m] += s_D[k][m] * r_GDut;
          }

#pragma unroll p_Nq
          for (int m = 0; m < p_Nq; m++) {
            r_Auk += s_D[m][j] * s_w[m][i];
            r_Auk += s_D[m][i] * s_v[j][m];
          }

          r_Au[k] += r_Auk;
        }
      }
    } // end Layer by layer

    @barrier();

    // write out
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
        const dlong id = element * p_Np + j * p_Nq + i;

#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          Aq[id + k * p_Nq * p_Nq] = r_Au[k];
        }
      }
    }
  }
}
#endif

#if p_knl == 7
@kernel void ellipticPartialAxCoeffHex3D_v7(const dlong Nelements,
                                       const dlong offset,
                                       const dlong loffset,
                                       @restrict const dlong *elementList,
                                       @restrict const dfloat *ggeo,
                                       @restrict const dfloat *D,
                                       @restrict const dfloat *S,
                                       @restrict const dfloat *lambda0,
                                       @restrict const dfloat *lambda1,
                                       @restrict const dfloat *q,
                                       @restrict dfloat *Aq)
{

  for (dlong e = 0; e < Nelements; e++; @outer(0)) {
#if (p_Nq % 2 == 0)
    @shared dfloat s_D[p_Nq][p_Nq + 1];
#else
    @shared dfloat s_D[p_Nq][p_Nq];
#endif
    @exclusive dfloat r_Au[p_Nq];

    @exclusive dlong element;

    @exclusive dfloat r_ur[p_Nq], r_us[p_Nq], r_ut[p_Nq];

    @shared dfloat s_tmp[p_Nq][p_Nq][p_Nq];

    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
        // load D into local memory
        //  s_D[i][j] = d \phi_i at node j
        s_D[j][i] = D[p_Nq * j + i]; // D is column major
        element = elementList[e];

        const dlong base = i + j * p_Nq + element * p_Np;
#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          const dlong id = base + k * p_Nq * p_Nq;
          s_tmp[k][j][i] = (id != -1) ? q[id] : 0.0;
          r_ur[k] = 0;
          r_us[k] = 0;
          r_ut[k] = 0;
          r_Au[k] = 0.0;          
        }
      }
    }
    @barrier();

    // grad in r
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {          
        for (int m = 0; m < p_Nq; m++) {
          dfloat Dim = s_D[i][m];
#pragma unroll p_Nq          
          for (int k = 0; k < p_Nq; k++) {
            r_ur[k] += Dim * s_tmp[k][j][m];
          }
        }
      }
    }

    // grad in s
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {          
        for (int m = 0; m < p_Nq; m++) {
          dfloat Djm = s_D[j][m];
#pragma unroll p_Nq          
          for (int k = 0; k < p_Nq; k++) {
            r_us[k] += Djm * s_tmp[k][m][i];
          }
        }
      }
    }    

    // grad in t
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {      
        for (int m = 0; m < p_Nq; m++) {
          dfloat umji = s_tmp[m][j][i];
#pragma unroll p_Nq          
          for (int k = 0; k < p_Nq; k++) {
            r_ut[k] += s_D[k][m] * umji;
          }
        }
      }
    }
    
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq        
        for (int k = 0; k < p_Nq; k++) {
          // prefetch geometric factors
          const dlong gbase = element * p_Nggeo * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
          const dfloat r_G00 = ggeo[gbase + p_G00ID * p_Np];
          const dfloat r_G01 = ggeo[gbase + p_G01ID * p_Np];
          const dfloat r_G02 = ggeo[gbase + p_G02ID * p_Np];
          const dfloat r_G11 = ggeo[gbase + p_G11ID * p_Np];
          const dfloat r_G12 = ggeo[gbase + p_G12ID * p_Np];
          const dfloat r_G22 = ggeo[gbase + p_G22ID * p_Np];

          const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
#ifndef p_poisson
          const dfloat r_GwJ = ggeo[gbase + p_GWJID * p_Np];
          const dfloat lbda1 =  lambda1[p_lambda*id + 0 * loffset];
#endif
          const dfloat lbda0 = lambda0[p_lambda*id + 0 * loffset];
          dfloat t_GDur  = lbda0 * (r_G00 * r_ur[k] + r_G01 * r_us[k] + r_G02 * r_ut[k]);
          dfloat t_GDus  = lbda0 * (r_G01 * r_ur[k] + r_G11 * r_us[k] + r_G12 * r_ut[k]);
          dfloat t_GDut  = lbda0 * (r_G02 * r_ur[k] + r_G12 * r_us[k] + r_G22 * r_ut[k]);
          r_ur[k] = t_GDur;
          r_us[k] = t_GDus;
          r_ut[k] = t_GDut;
#ifndef p_poisson
          r_Au[k] += r_GwJ * lbda1 * s_tmp[k][j][i];
#endif
        }
      }
    }

    // div in t
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
        for (int k = 0; k < p_Nq; k++) {
          dfloat ut_kij = r_ut[k];
#pragma unroll p_Nq          
          for (int m = 0; m < p_Nq; m++) {
            r_Au[m] += s_D[k][m] * ut_kij;
          }
        }
      }
    }

    // div in r
    @barrier();
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq        
        for (int k = 0; k < p_Nq; k++) {
          s_tmp[k][j][i] = r_ur[k];
        }
      }
    }
    @barrier();
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {    
        for (int m = 0; m < p_Nq; m++) {
          dfloat Dmi = s_D[m][i];
#pragma unroll p_Nq          
          for (int k = 0; k < p_Nq; k++) {
            r_Au[k] += Dmi * s_tmp[k][j][m];
          }
        }
      }
    }

    // div in s
    @barrier();    
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
#pragma unroll p_Nq        
        for (int k = 0; k < p_Nq; k++) {
          s_tmp[k][j][i] = r_us[k];
        }
      }
    }
    @barrier();
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
        for (int m = 0; m < p_Nq; m++) {
          dfloat Dmj = s_D[m][j];
#pragma unroll p_Nq          
          for (int k = 0; k < p_Nq; k++) {
            r_Au[k] += Dmj * s_tmp[k][m][i];
          }
        }
      }
    } 

    // write out
    for (int j = 0; j < p_Nq; ++j; @inner(1)) {
      for (int i = 0; i < p_Nq; ++i; @inner(0)) {
        const dlong id = element * p_Np + j * p_Nq + i;

#pragma unroll p_Nq
        for (int k = 0; k < p_Nq; k++) {
          Aq[id + k * p_Nq * p_Nq] = r_Au[k];
        }
      }
    }
  }
}
#endif
