//
// nekRS User Defined File
//
#include "udf.hpp"
#include "nekrsAscent.hpp"
#include "nekrsAscent.cpp"

#ifdef __okl__

#include "pb.oudf"

#endif

void UDF_Setup(nrs_t *nrs) {

  /*
  {
    cds_t *cds = nrs->cds;
    mesh_t *meshV = nrs->meshV; 
    mesh_t* meshT;
    (nrs->cds) ? meshT = cds->mesh[0] : meshT = meshV; // cht

    std::vector< std::tuple<std::string, occa::memory, dlong> > ascentFields;

    auto o_u  = nrs->o_U.slice(0 * nrs->fieldOffset , nrs->fieldOffset);
    auto o_v  = nrs->o_U.slice(1 * nrs->fieldOffset , nrs->fieldOffset);
    auto o_w  = nrs->o_U.slice(2 * nrs->fieldOffset , nrs->fieldOffset);
    auto o_s0 = cds->o_S + cds->fieldOffsetScan[0];
    auto o_s1 = cds->o_S + cds->fieldOffsetScan[1];

    ascentFields.push_back(std::make_tuple("vel_x", o_u, meshV->Nlocal));
    ascentFields.push_back(std::make_tuple("vel_y", o_v, meshV->Nlocal));
    ascentFields.push_back(std::make_tuple("vel_z", o_w, meshV->Nlocal));
    ascentFields.push_back(std::make_tuple("temperature", o_s0, cds->mesh[0]->Nlocal));
    ascentFields.push_back(std::make_tuple("scalar01", o_s1, meshV->Nlocal));

    nekrsAscent::setup(meshT, nrs->fieldOffset, ascentFields);
  }
  */

  nekrsAscent::setup(nrs);
}

void UDF_ExecuteStep(nrs_t *nrs, double time, int tstep) {

  cds_t *cds = nrs->cds;
  mesh_t* meshT; 
  (nrs->cds) ? meshT = cds->mesh[0] : meshT = nrs->meshV; 

  // compute radius, stored it in scalar01
  occa::memory o_S1 = cds->o_S + cds->fieldOffsetScan[1];
  if (tstep==0)
    compRad(meshT->Nlocal, meshT->o_x, meshT->o_y, o_S1);

  nekrsAscent::run(time, tstep);
}
